### Prompt:
"
You are an expert Python developer and software architect. I have provided the complete codebase for a **Personal Finance Assistant API** built with FastAPI, SQLAlchemy, and various other libraries. The project follows the specified directory structure.

Please provide a **comprehensive, line-by-line explanation** of every single file in this codebase. For each file, include:

1. **File Purpose:** A concise summary of the file's role within the overall project.
    
2. **Import Analysis:** Explain every import statement—why the module/library is needed and how it's used in _this specific_ context.
    
3. **Class & Function Breakdown:** For every class, function, and method:
    
    - **Declaration:** Explain the purpose of its definition (e.g., `class ReceiptBase(BaseModel):`, `def verify_password(...):`).
        
    - **Parameters/Attributes:** Explain the purpose and data type of every parameter (for functions) and every attribute/column (for Pydantic models and SQLAlchemy models). For example, why does the `Receipt` model have a `parsed_text` column that is nullable?
        
    - **Logic:** Explain the logic inside every function and method line-by-line. Don't just restate the code; explain the _why_ behind the operations (e.g., "This query filters transactions by date because...", "This regex pattern is designed to capture amounts in the format...", "We use `uuid.uuid4()` here to generate a unique filename to prevent overwrites and ensure security").
        
    - **Decorators:** Explain all FastAPI decorators (e.g., `@router.post("/", response_model=Transaction)`)—what HTTP method they handle, what path they define, what the expected input and output schemas are, and any dependencies like authentication.
        
    - **Error Handling:** Explain the purpose of all `try...except` blocks and `HTTPException` raises. What specific errors are being caught, and why is that important for the application's stability and user experience?
        
4. **Inter-File Relationships:** Constantly highlight how different files and components interact. For example:
    
    - How does `auth_service.py` use `security.py`?
        
    - How does `receipts.py` (the router) call `receipt_service.py`, which in turn uses `ocr_parser.py` and `pdf_parser.py`?
        
    - How are the Pydantic schemas in `schemas/` used by the routers, services, and models?
        
    - Trace the complete flow for a request, from the endpoint in a router to the service, to the database model, and back again.
        
5. **Security & Best Practices:** Point out security considerations (e.g., password hashing with `bcrypt`, using `get_password_hash` and `verify_password`, using `Depends(get_current_user)` for protection, generating secure filenames with `uuid`). Also, comment on software design patterns used (e.g., dependency injection with `Depends`, service layers, separation of concerns between routers, services, and models).
    
6. **Configuration & Deployment:** Explain the settings in `config.py` and how they are used throughout the app (e.g., `DATABASE_URL`, `SECRET_KEY`). Explain the CORS setup in `main.py` and the `if __name__ == "__main__":` block for deployment.
    
7. **Dependencies:** For `requirements.txt`, explain why each library is crucial for the project (e.g., `fastapi` for the web framework, `pytesseract` for OCR, `pdfplumber` for PDF text extraction, `python-jose` for JWT tokens).
    

**Crucial Instruction:** Do not skip or generalize any part of the code. Assume I am a competent programmer who lacks specific knowledge of this codebase. Your goal is to make me an expert on it, enabling me to confidently debug, modify, and extend this application. Organize your explanation by following the provided directory structure exactly, starting from `main.py` and moving through each folder and file in a logical order.
"



I'll provide a comprehensive, line-by-line explanation of each file in your Personal Finance Assistant API. Let's start with the project structure and work through each component.

### File: requirements.txt

**Purpose**: Lists all Python dependencies required for the project.

**Dependencies Analysis**:

- `fastapi==0.104.1`: Web framework for building APIs with automatic docs
    
- `uvicorn[standard]==0.24.0`: ASGI server for running FastAPI applications
    
- `sqlalchemy==2.0.23`: ORM for database interactions
    
- `pydantic==2.5.0`: Data validation and settings management
    
- `pydantic-settings==2.1.0`: Extension for Pydantic settings management
    
- `python-jose[cryptography]==3.3.0`: JWT token implementation
    
- `passlib==1.7.4`: Password hashing library
    
- `bcrypt==4.0.1`: Password hashing algorithm
    
- `python-multipart==0.0.6`: Required for form data parsing (file uploads)
    
- `pytesseract==0.3.10`: OCR library for text extraction from images
    
- `pdfplumber==0.10.3`: PDF text extraction library
    
- `pillow==10.0.0`: Image processing library (required by pytesseract)
    
- `pypdf2==3.0.1`: Alternative PDF processing library
    

### File: [config.py](https://config.py/) (app/core/config.py)

**Purpose**: Application configuration using Pydantic settings management.

**Line-by-line Analysis**:

```python
from pydantic_settings import BaseSettings  # For settings management
import os  # For environment variable access

class Settings(BaseSettings):
    DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///./finance_assistant.db")
    # Database connection string with SQLite fallback
    SECRET_KEY: str = os.getenv("SECRET_KEY", "asdfghjkl;")
    # Secret key for JWT token signing (should be changed in production)
    ALGORITHM: str = os.getenv("ALGORITHM", "HS256")
    # JWT signing algorithm
    ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))
    # Token expiration time
    ALLOWED_ORIGINS: str = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000,http://localhost:8000")
    # CORS allowed origins

settings = Settings()  # Instantiated settings object
```

### File: [security.py](https://security.py/) (app/core/security.py)

**Purpose**: Password hashing and verification utilities.

**Line-by-line Analysis**:

```python
from passlib.context import CryptContext  # Password hashing context

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
# Configure password hashing with bcrypt scheme

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)
    # Verify plain password against hashed version

def get_password_hash(password):
    return pwd_context.hash(password)
    # Generate password hash
```



### File: [main.py](https://main.py/)

**Purpose**: Application entry point and server configuration.

**Line-by-line Analysis**:

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.db.base import Base
from app.db.session import engine
from app.routers import auth, transactions, receipts
from app.core.config import settings
import os

Base.metadata.create_all(bind=engine)  # Create database tables

app = FastAPI(title="Personal Finance Assistant", version="1.0.0")

# CORS middleware configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.ALLOWED_ORIGINS.split(","),  # Split comma-separated origins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include route handlers
app.include_router(auth.router)
app.include_router(transactions.router)
app.include_router(receipts.router)

@app.get("/")
def read_root():
    return {"message": "Personal Finance Assistant API"}

@app.get("/health")
def health_check():
    return {"status": "healthy"}

# Production deployment configuration
if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PORT", 8000))  # Get port from environment
    uvicorn.run(app, host="0.0.0.0", port=port)  # Run on all interfaces
```


### File: [base.py](https://base.py/) (app/db/base.py)

**Purpose**: SQLAlchemy base class for all models.

**Line-by-line Analysis**:

```python
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()  # Create base class for ORM models
```


### File: [session.py](https://session.py/) (app/db/session.py)

**Purpose**: Database session management.

**Line-by-line Analysis**:

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

engine = create_engine(
    settings.DATABASE_URL, connect_args={"check_same_thread": False}
)
# Create database engine with SQLite thread connection fix

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
# Configure session factory

def get_db():
    db = SessionLocal()
    try:
        yield db  # Provide session to dependency
    finally:
        db.close()  # Ensure session closure
```


### File: [user.py](https://user.py/) (app/models/user.py)

**Purpose**: User model definition.

**Line-by-line Analysis**:

```python
from sqlalchemy import Column, Integer, String, DateTime
from sqlalchemy.sql import func
from app.db.base import Base

class User(Base):
    __tablename__ = "users"  # Database table name

    id = Column(Integer, primary_key=True, index=True)  # Primary key
    username = Column(String, unique=True, index=True, nullable=False)
    # Unique username with index
    password_hash = Column(String, nullable=False)  # Hashed password storage
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    # Automatic timestamp creation
```


### File: [transaction.py](https://transaction.py/) (app/models/transaction.py)

**Purpose**: Transaction model definition.

**Line-by-line Analysis**:

```python
from sqlalchemy import Column, Integer, Float, String, Text, Date, DateTime, ForeignKey, Enum
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum
from app.db.base import Base

class TransactionType(enum.Enum):
    INCOME = "income"
    EXPENSE = "expense"  # Enum for transaction types

class Transaction(Base):
    __tablename__ = "transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    # Foreign key to users table
    amount = Column(Float, nullable=False)  # Transaction amount
    type = Column(Enum(TransactionType), nullable=False)  # Income/expense
    category = Column(String, nullable=False)  # Transaction category
    description = Column(Text, nullable=True)  # Optional description
    date = Column(Date, nullable=False)  # Transaction date
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    # Automatic timestamp
    
    user = relationship("User")  # Relationship to User model
```


### File: [receipt.py](https://receipt.py/) (app/models/receipt.py)

**Purpose**: Receipt model definition.

**Line-by-line Analysis**:

```python
from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from app.db.base import Base

class Receipt(Base):
    __tablename__ = "receipts"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    # Foreign key to users table
    file_path = Column(String, nullable=False)  # Path to uploaded file
    parsed_text = Column(Text, nullable=True)  # OCR-extracted text (can be null)
    uploaded_at = Column(DateTime(timezone=True), server_default=func.now())
    # Automatic upload timestamp
    
    user = relationship("User")  # Relationship to User model
```


### File: [user.py](https://user.py/) (app/schemas/user.py)

**Purpose**: Pydantic schemas for user data validation.

**Line-by-line Analysis**:

```python
from pydantic import BaseModel
from datetime import datetime

class UserBase(BaseModel):
    username: str  # Base schema with common fields

class UserCreate(UserBase):
    password: str  # Includes password for registration

class User(UserBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True  # Allow ORM mode

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None  # Token payload data
```


### File: [transaction.py](https://transaction.py/) (app/schemas/transaction.py)

**Purpose**: Pydantic schemas for transaction data.

**Line-by-line Analysis**:

```python
from pydantic import BaseModel
from datetime import date, datetime
from enum import Enum
from typing import Optional

class TransactionType(str, Enum):
    INCOME = "income"
    EXPENSE = "expense"  # String enum for transaction type

class TransactionBase(BaseModel):
    amount: float
    type: TransactionType
    category: str
    description: Optional[str] = None  # Optional field
    date: date

class TransactionCreate(TransactionBase):
    pass  # Creation schema same as base

class Transaction(TransactionBase):
    id: int
    user_id: int
    created_at: datetime

    class Config:
        from_attributes = True  # ORM mode

class TransactionSummary(BaseModel):
    category: str
    total_amount: float  # For category summaries

class DateSummary(BaseModel):
    date: date
    total_amount: float  # For date summaries

class PaginatedTransactions(BaseModel):
    items: list[Transaction]
    total: int
    page: int
    pages: int  # For paginated responses
```


### File: [receipt.py](https://receipt.py/) (app/schemas/receipt.py)

**Purpose**: Pydantic schemas for receipt data.

**Line-by-line Analysis**:

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class ReceiptBase(BaseModel):
    file_path: str  # Base schema with file path

class ReceiptCreate(ReceiptBase):
    pass  # Creation schema same as base

class Receipt(ReceiptBase):
    id: int
    user_id: int
    parsed_text: Optional[str] = None  # OCR text can be null
    uploaded_at: datetime

    class Config:
        from_attributes = True  # ORM mode
```


### File: auth_[service.py](https://service.py/) (app/services/auth_service.py)

**Purpose**: Authentication business logic.

**Line-by-line Analysis**:

```python
from datetime import datetime, timedelta
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from app.models.user import User
from app.schemas.user import UserCreate
from app.core.config import settings
from app.core.security import verify_password, get_password_hash
from app.db.session import get_db

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")
# OAuth2 password bearer token configuration

class AuthService:
    def __init__(self, db: Session):
        self.db = db
    
    def register_user(self, user_data: UserCreate) -> User:
        existing_user = self.db.query(User).filter(User.username == user_data.username).first()
        if existing_user:
            raise ValueError("Username already registered")
        # Check for existing username
        
        hashed_password = get_password_hash(user_data.password)
        # Hash password
        user = User(username=user_data.username, password_hash=hashed_password)
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user
    
    def authenticate_user(self, username: str, password: str) -> User | None:
        user = self.db.query(User).filter(User.username == username).first()
        if not user or not verify_password(password, user.password_hash):
            return None  # Verify credentials
        return user
    
    def create_access_token(self, data: dict) -> str:
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        to_encode.update({"exp": expire})  # Add expiration
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt  # Create JWT token

def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")  # Get username from token
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception  # Handle JWT errors
    
    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise credentials_exception
    return user  # Return current user
```


### File: transaction_[service.py](https://service.py/) (app/services/transaction_service.py)

**Purpose**: Transaction business logic.

**Line-by-line Analysis**:

```python
from sqlalchemy.orm import Session
from sqlalchemy import func, and_
from typing import Optional
from datetime import date
from app.models.transaction import Transaction, TransactionType
from app.schemas.transaction import TransactionCreate, TransactionSummary, DateSummary, PaginatedTransactions

class TransactionService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_transaction(self, user_id: int, transaction_data: TransactionCreate) -> Transaction:
        transaction = Transaction(
            user_id=user_id,
            amount=transaction_data.amount,
            type=TransactionType(transaction_data.type),  # Convert to enum
            category=transaction_data.category,
            description=transaction_data.description,
            date=transaction_data.date
        )
        self.db.add(transaction)
        self.db.commit()
        self.db.refresh(transaction)
        return transaction
    
    def get_transactions(
        self,
        user_id: int,
        start_date: Optional[date],
        end_date: Optional[date],
        type: Optional[str],
        category: Optional[str],
        page: int,
        limit: int
    ) -> PaginatedTransactions:
        query = self.db.query(Transaction).filter(Transaction.user_id == user_id)
        
        # Apply filters
        if start_date:
            query = query.filter(Transaction.date >= start_date)
        if end_date:
            query = query.filter(Transaction.date <= end_date)
        if type:
            query = query.filter(Transaction.type == TransactionType(type))
        if category:
            query = query.filter(Transaction.category == category)
        
        total = query.count()  # Get total count
        
        # Apply pagination
        transactions = query.order_by(Transaction.date.desc()).offset((page - 1) * limit).limit(limit).all()
        
        pages = (total + limit - 1) // limit  # Calculate total pages
        
        return PaginatedTransactions(
            items=transactions,
            total=total,
            page=page,
            pages=pages
        )
    
    def get_category_summary(
        self,
        user_id: int,
        start_date: Optional[date],
        end_date: Optional[date],
        type: Optional[str]
    ) -> list[TransactionSummary]:
        query = self.db.query(
            Transaction.category,
            func.sum(Transaction.amount).label("total_amount")
        ).filter(Transaction.user_id == user_id)
        
        # Apply filters
        if start_date:
            query = query.filter(Transaction.date >= start_date)
        if end_date:
            query = query.filter(Transaction.date <= end_date)
        if type:
            query = query.filter(Transaction.type == TransactionType(type))
        
        results = query.group_by(Transaction.category).all()
        
        return [
            TransactionSummary(category=row.category, total_amount=row.total_amount)
            for row in results
        ]
    
    def get_date_summary(
        self,
        user_id: int,
        start_date: Optional[date],
        end_date: Optional[date],
        type: Optional[str]
    ) -> list[DateSummary]:
        query = self.db.query(
            Transaction.date,
            func.sum(Transaction.amount).label("total_amount")
        ).filter(Transaction.user_id == user_id)
        
        # Apply filters
        if start_date:
            query = query.filter(Transaction.date >= start_date)
        if end_date:
            query = query.filter(Transaction.date <= end_date)
        if type:
            query = query.filter(Transaction.type == TransactionType(type))
        
        results = query.group_by(Transaction.date).order_by(Transaction.date).all()
        
        return [
            DateSummary(date=row.date, total_amount=row.total_amount)
            for row in results
        ]
```

### File: receipt_[service.py](https://service.py/) (app/services/receipt_service.py)

**Purpose**: Receipt processing business logic.

**Line-by-line Analysis**:

```python
from sqlalchemy.orm import Session
from app.models.receipt import Receipt
from app.models.transaction import Transaction, TransactionType
from app.utils.ocr_parser import extract_text_from_image, parse_receipt_text
from app.utils.pdf_parser import extract_text_from_pdf, parse_transactions_from_text
import re
from datetime import datetime

class ReceiptService:
    def __init__(self, db: Session):
        self.db = db
    
    def process_receipt(self, user_id: int, file_path: str, file_extension: str) -> Receipt:
        # Handle different file types
        if file_extension.lower() in ['jpg', 'jpeg', 'png', 'bmp', 'tiff']:
            text = extract_text_from_image(file_path)
        elif file_extension.lower() == 'pdf':
            text = extract_text_from_pdf(file_path)
        else:
            raise ValueError("Unsupported file format")
        
        # Create receipt record
        receipt = Receipt(
            user_id=user_id,
            file_path=file_path,
            parsed_text=text
        )
        self.db.add(receipt)
        self.db.commit()
        self.db.refresh(receipt)
        
        # Attempt to create transaction from receipt
        try:
            transaction_data = parse_receipt_text(text)
            if transaction_data:
                transaction = Transaction(
                    user_id=user_id,
                    amount=transaction_data['amount'],
                    type=TransactionType.EXPENSE,  # Receipts are typically expenses
                    category=transaction_data.get('category', 'Other'),
                    description=transaction_data.get('description', 'From receipt'),
                    date=transaction_data.get('date', datetime.now().date())
                )
                self.db.add(transaction)
                self.db.commit()
        except Exception as e:
            # Gracefully handle OCR parsing errors
            pass
        
        return receipt
    
    def process_pdf_transactions(self, user_id: int, file_path: str) -> list[Receipt]:
        text = extract_text_from_pdf(file_path)
        
        receipt = Receipt(
            user_id=user_id,
            file_path=file_path,
            parsed_text=text[:1000]  # Store first 1000 characters
        )
        self.db.add(receipt)
        self.db.commit()
        self.db.refresh(receipt)
        
        transactions = parse_transactions_from_text(text)
        
        created_transactions = []
        for transaction_data in transactions:
            transaction = Transaction(
                user_id=user_id,
                amount=transaction_data['amount'],
                type=TransactionType(transaction_data['type']),
                category=transaction_data.get('category', 'Other'),
                description=transaction_data.get('description', 'From PDF statement'),
                date=transaction_data.get('date', datetime.now().date())
            )
            self.db.add(transaction)
            created_transactions.append(transaction)
        
        self.db.commit()
        
        return [receipt]  # Return single receipt (interface consistency)
```

### File: ocr_[parser.py](https://parser.py/) (app/utils/ocr_parser.py)

**Purpose**: OCR text extraction and receipt parsing.

**Line-by-line Analysis**:

```python
try:
    import pytesseract
    from PIL import Image
    OCR_AVAILABLE = True
    
    # Windows-specific tesseract path (would need adjustment for other OS)
    pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'
except ImportError:
    OCR_AVAILABLE = False
    print("pytesseract not available. OCR functionality disabled.")

import re
from datetime import datetime
import os

def extract_text_from_image(image_path: str) -> str:
    try:
        if not OCR_AVAILABLE:
            raise Exception("pytesseract is not available. Please check the installation.")
        
        image = Image.open(image_path)
        text = pytesseract.image_to_string(image)  # Perform OCR
        return text
    except Exception as e:
        raise Exception(f"Failed to extract text from image: {str(e)}")

def parse_receipt_text(text: str) -> dict:
    # Regex patterns for amount and date extraction
    amount_pattern = r'\$?\d+\.\d{2}'
    date_pattern = r'\d{1,2}[/-]\d{1,2}[/-]\d{2,4}'
    
    # Find all amounts and convert to float
    amounts = re.findall(amount_pattern, text)
    amounts = [float(amount.replace('$', '').replace(',', '')) for amount in amounts]
    
    if not amounts:
        return None
    
    total_amount = max(amounts)  # Assume largest amount is total
    
    # Date parsing with multiple format attempts
    dates = re.findall(date_pattern, text)
    transaction_date = None
    if dates:
        try:
            transaction_date = datetime.strptime(dates[0], '%m/%d/%Y').date()
        except:
            try:
                transaction_date = datetime.strptime(dates[0], '%m-%d-%Y').date()
            except:
                transaction_date = datetime.now().date()
    else:
        transaction_date = datetime.now().date()
    
    # Category detection using keyword matching
    category = "Other"
    category_keywords = {
        "Food": ["restaurant", "cafe", "food", "groceries", "supermarket", "dining"],
        "Transport": ["gas", "fuel", "taxi", "uber", "lyft", "transport", "parking"],
        "Shopping": ["store", "shop", "mall", "clothing", "electronics", "amazon"],
        "Entertainment": ["movie", "cinema", "concert", "game", "entertainment"],
        "Utilities": ["electricity", "water", "gas", "internet", "phone", "utility"],
    }
    
    text_lower = text.lower()
    for cat, keywords in category_keywords.items():
        if any(keyword in text_lower for keyword in keywords):
            category = cat
            break
    
    return {
        "amount": total_amount,
        "date": transaction_date,
        "category": category,
        "description": "From receipt scan"
    }
```

### File: pdf_[parser.py](https://parser.py/) (app/utils/pdf_parser.py)

**Purpose**: PDF text extraction and transaction parsing.

**Line-by-line Analysis**:

```python
import pdfplumber
import re
from datetime import datetime

def extract_text_from_pdf(pdf_path: str) -> str:
    try:
        text = ""
        with pdfplumber.open(pdf_path) as pdf:
            for page in pdf.pages:
                text += page.extract_text() + "\n"  # Extract text from each page
        return text
    except Exception as e:
        raise Exception(f"Failed to extract text from PDF: {str(e)}")

def parse_transactions_from_text(text: str) -> list[dict]:
    transactions = []
    
    # Pattern for transaction lines (date, description, amount)
    transaction_pattern = r'(\d{1,2}/\d{1,2}/\d{2,4})\s+(.*?)\s+(-?\$?\d+\.\d{2})'
    
    matches = re.findall(transaction_pattern, text)
    
    for match in matches:
        date_str, description, amount_str = match
        
        try:
            transaction_date = datetime.strptime(date_str, '%m/%d/%Y').date()
            
            amount = float(amount_str.replace('$', '').replace(',', ''))
            transaction_type = "expense" if amount < 0 else "income"
            amount = abs(amount)
            
            # Category detection
            category = "Other"
            description_lower = description.lower()
            
            if any(word in description_lower for word in ['restaurant', 'cafe', 'food', 'groceries']):
                category = "Food"
            elif any(word in description_lower for word in ['gas', 'fuel', 'taxi', 'uber', 'transport']):
                category = "Transport"
            elif any(word in description_lower for word in ['electricity', 'water', 'gas', 'internet', 'phone']):
                category = "Utilities"
            elif any(word in description_lower for word in ['salary', 'payment', 'deposit']):
                category = "Income"
            
            transactions.append({
                "amount": amount,
                "type": transaction_type,
                "category": category,
                "description": description.strip(),
                "date": transaction_date
            })
        except Exception as e:
            continue  # Skip malformed transactions
    
    return transactions
```

### File: [auth.py](https://auth.py/) (app/routers/auth.py)

**Purpose**: Authentication route handlers.

**Line-by-line Analysis**:

```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.schemas.user import User, UserCreate, Token
from app.services.auth_service import AuthService

router = APIRouter(prefix="/auth", tags=["auth"])  # Router configuration

@router.post("/register", response_model=User)
def register(user_data: UserCreate, db: Session = Depends(get_db)):
    auth_service = AuthService(db)
    try:
        user = auth_service.register_user(user_data)
        return user
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
        # Handle duplicate username

@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    auth_service = AuthService(db)
    user = auth_service.authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = auth_service.create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}
```

### File: [transactions.py](https://transactions.py/) (app/routers/transactions.py)

**Purpose**: Transaction route handlers.

**Line-by-line Analysis**:

```python
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import Optional
from datetime import date
from app.db.session import get_db
from app.schemas.transaction import (
    Transaction, TransactionCreate, TransactionSummary, DateSummary, PaginatedTransactions
)
from app.services.transaction_service import TransactionService
from app.services.auth_service import get_current_user
from app.models.user import User

router = APIRouter(prefix="/transactions", tags=["transactions"])

@router.post("/", response_model=Transaction)
def create_transaction(
    transaction_data: TransactionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)  # Requires authentication
):
    transaction_service = TransactionService(db)
    return transaction_service.create_transaction(current_user.id, transaction_data)

@router.get("/", response_model=PaginatedTransactions)
def get_transactions(
    start_date: Optional[date] = Query(None, description="Start date for filtering"),
    end_date: Optional[date] = Query(None, description="End date for filtering"),
    type: Optional[str] = Query(None, description="Filter by type (income/expense)"),
    category: Optional[str] = Query(None, description="Filter by category"),
    page: int = Query(1, ge=1),  # Page number validation
    limit: int = Query(10, ge=1, le=100),  # Limit validation
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    return transaction_service.get_transactions(
        current_user.id, start_date, end_date, type, category, page, limit
    )

@router.get("/summary/category", response_model=list[TransactionSummary])
def get_category_summary(
    start_date: Optional[date] = Query(None, description="Start date for filtering"),
    end_date: Optional[date] = Query(None, description="End date for filtering"),
    type: Optional[str] = Query(None, description="Filter by type (income/expense)"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    return transaction_service.get_category_summary(
        current_user.id, start_date, end_date, type
    )

@router.get("/summary/date", response_model=list[DateSummary])
def get_date_summary(
    start_date: Optional[date] = Query(None, description="Start date for filtering"),
    end_date: Optional[date] = Query(None, description="End date for filtering"),
    type: Optional[str] = Query(None, description="Filter by type (income/expense)"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    return transaction_service.get_date_summary(
        current_user.id, start_date, end_date, type
    )
```

### File: [receipts.py](https://receipts.py/) (app/routers/receipts.py)

**Purpose**: Receipt route handlers.

**Line-by-line Analysis**:

```python
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form
from sqlalchemy.orm import Session
from typing import Optional
from app.db.session import get_db
from app.schemas.receipt import Receipt
from app.services.receipt_service import ReceiptService
from app.services.auth_service import get_current_user
from app.models.user import User
import os
import uuid

router = APIRouter(prefix="/receipts", tags=["receipts"])

@router.post("/upload", response_model=Receipt)
async def upload_receipt(
    file: UploadFile = File(...),  # File upload parameter
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    os.makedirs("uploads", exist_ok=True)  # Ensure upload directory exists
    
    # Generate unique filename
    file_extension = file.filename.split(".")[-1]
    filename = f"{uuid.uuid4()}.{file_extension}"
    file_path = os.path.join("uploads", filename)
    
    # Save uploaded file
    with open(file_path, "wb") as buffer:
        content = await file.read()
        buffer.write(content)
    
    receipt_service = ReceiptService(db)
    return receipt_service.process_receipt(current_user.id, file_path, file_extension)

@router.post("/upload-pdf", response_model=list[Receipt])
async def upload_pdf_transactions(
    file: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    os.makedirs("uploads", exist_ok=True)
    
    file_extension = file.filename.split(".")[-1]
    filename = f"{uuid.uuid4()}.{file_extension}"
    file_path = os.path.join("uploads", filename)
    
    with open(file_path, "wb") as buffer:
        content = await file.read()
        buffer.write(content)
    
    receipt_service = ReceiptService(db)
    return receipt_service.process_pdf_transactions(current_user.id, file_path)
```
This comprehensive breakdown covers all components of your Personal Finance Assistant API. The application follows best practices for FastAPI development, including proper separation of concerns, dependency injection, security measures, and error handling. The architecture allows for easy maintenance and future extensions.

