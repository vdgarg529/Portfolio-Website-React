**Phase 0 (Very Easy, Interview-Safe Features):** 
1. Sorting & Filtering: Sort transactions by date, amount, or category. Add simple filters like income/expenses. 
2. Pagination: Support `?page=1&limit=10` for transactions API. 
3. Category Tagging: Add categories/tags (Food, Rent, Travel) for transactions with CRUD endpoints. 
4. Monthly Summary API: Provide total income, expenses, and balance for a given month. 
5. Transaction Notes: Add a free-text note field for transactions. 
6. Update/Delete Transactions: Add endpoints for updating and deleting transactions (soft delete optional). 
7. Authentication Enhancement: Add password reset or change password functionality.


## 1. Sorting & Filtering Enhancement

**Files to modify:**

- `services/transaction_service.py`
    
- `routers/transactions.py`
    

**Implementation:**

1. In `transaction_service.py`, enhance the `get_transactions` method:
    

```python
def get_transactions(
    self,
    user_id: int,
    start_date: Optional[date],
    end_date: Optional[date],
    type: Optional[str],
    category: Optional[str],
    sort_by: str = "date",  # New parameter
    sort_order: str = "desc",  # New parameter
    page: int,
    limit: int
) -> PaginatedTransactions:
    query = self.db.query(Transaction).filter(Transaction.user_id == user_id)
    
    # Existing filtering
    if start_date:
        query = query.filter(Transaction.date >= start_date)
    if end_date:
        query = query.filter(Transaction.date <= end_date)
    if type:
        query = query.filter(Transaction.type == TransactionType(type))
    if category:
        query = query.filter(Transaction.category == category)
    
    # Add sorting
    sort_column = {
        "date": Transaction.date,
        "amount": Transaction.amount,
        "category": Transaction.category
    }.get(sort_by, Transaction.date)
    
    if sort_order == "asc":
        query = query.order_by(sort_column.asc())
    else:
        query = query.order_by(sort_column.desc())
    
    # Existing pagination
    total = query.count()
    transactions = query.offset((page - 1) * limit).limit(limit).all()
    pages = (total + limit - 1) // limit
    
    return PaginatedTransactions(
        items=transactions,
        total=total,
        page=page,
        pages=pages
    )
```


2. In `transactions.py`, update the endpoint to accept sorting parameters:
    

```python
@router.get("/", response_model=PaginatedTransactions)
def get_transactions(
    start_date: Optional[date] = Query(None, description="Start date for filtering"),
    end_date: Optional[date] = Query(None, description="End date for filtering"),
    type: Optional[str] = Query(None, description="Filter by type (income/expense)"),
    category: Optional[str] = Query(None, description="Filter by category"),
    sort_by: str = Query("date", description="Sort by field (date, amount, category)"),
    sort_order: str = Query("desc", description="Sort order (asc, desc)"),
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    return transaction_service.get_transactions(
        current_user.id, start_date, end_date, type, category, sort_by, sort_order, page, limit
    )
```

### 2. Pagination (Already Implemented)

Your code already has pagination support in the `get_transactions` method. Good job!

## 3. Category Management

**Files to create/modify:**

- `models/category.py` (new)
    
- `schemas/category.py` (new)
    
- `services/category_service.py` (new)
    
- `routers/categories.py` (new)
    

**Implementation:**

1. Create `models/category.py`:
    

```python
from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship
from app.db.base import Base

class Category(Base):
    __tablename__ = "categories"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    name = Column(String, nullable=False)
    type = Column(String, nullable=False)  # 'income' or 'expense'
    
    user = relationship("User")
```


2. Create `schemas/category.py`:
    

```python
from pydantic import BaseModel
from typing import Optional

class CategoryBase(BaseModel):
    name: str
    type: str

class CategoryCreate(CategoryBase):
    pass

class Category(CategoryBase):
    id: int
    user_id: int
    
    class Config:
        from_attributes = True
```


2. Create `services/category_service.py`:
    

```python
from sqlalchemy.orm import Session
from app.models.category import Category

class CategoryService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_category(self, user_id: int, category_data):
        category = Category(**category_data.dict(), user_id=user_id)
        self.db.add(category)
        self.db.commit()
        self.db.refresh(category)
        return category
    
    def get_categories(self, user_id: int):
        return self.db.query(Category).filter(Category.user_id == user_id).all()
    
    def update_category(self, category_id: int, user_id: int, update_data):
        category = self.db.query(Category).filter(
            Category.id == category_id, 
            Category.user_id == user_id
        ).first()
        
        if not category:
            return None
        
        for field, value in update_data.items():
            setattr(category, field, value)
        
        self.db.commit()
        self.db.refresh(category)
        return category
    
    def delete_category(self, category_id: int, user_id: int):
        category = self.db.query(Category).filter(
            Category.id == category_id, 
            Category.user_id == user_id
        ).first()
        
        if not category:
            return False
        
        self.db.delete(category)
        self.db.commit()
        return True
```

2. Create `routers/categories.py`:
    

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.schemas.category import Category, CategoryCreate
from app.services.category_service import CategoryService
from app.services.auth_service import get_current_user
from app.models.user import User

router = APIRouter(prefix="/categories", tags=["categories"])

@router.post("/", response_model=Category)
def create_category(
    category_data: CategoryCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    category_service = CategoryService(db)
    return category_service.create_category(current_user.id, category_data)

@router.get("/", response_model=list[Category])
def get_categories(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    category_service = CategoryService(db)
    return category_service.get_categories(current_user.id)

@router.put("/{category_id}", response_model=Category)
def update_category(
    category_id: int,
    category_data: CategoryCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    category_service = CategoryService(db)
    category = category_service.update_category(category_id, current_user.id, category_data.dict())
    if not category:
        raise HTTPException(status_code=404, detail="Category not found")
    return category

@router.delete("/{category_id}")
def delete_category(
    category_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    category_service = CategoryService(db)
    success = category_service.delete_category(category_id, current_user.id)
    if not success:
        raise HTTPException(status_code=404, detail="Category not found")
    return {"message": "Category deleted successfully"}
```

2. Update `main.py` to include the categories router:
    

```python
# Add import
from app.routers import categories

# Add to routers
app.include_router(categories.router)
```

## 4. Monthly Summary API

**Files to modify:**

- `services/transaction_service.py`
    
- `routers/transactions.py`
    

**Implementation:**

1. In `transaction_service.py`, add a new method:
    

```python
def get_monthly_summary(self, user_id: int, year: int, month: int) -> dict:
    from datetime import date
    from sqlalchemy import extract, func
    
    # Get start and end dates for the month
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year+1, 1, 1)
    else:
        end_date = date(year, month+1, 1)
    
    # Query for income
    income = self.db.query(func.sum(Transaction.amount)).filter(
        Transaction.user_id == user_id,
        Transaction.type == TransactionType.INCOME,
        Transaction.date >= start_date,
        Transaction.date < end_date
    ).scalar() or 0.0
    
    # Query for expenses
    expenses = self.db.query(func.sum(Transaction.amount)).filter(
        Transaction.user_id == user_id,
        Transaction.type == TransactionType.EXPENSE,
        Transaction.date >= start_date,
        Transaction.date < end_date
    ).scalar() or 0.0
    
    return {
        "income": income,
        "expenses": expenses,
        "balance": income - expenses
    }
```

1. In `transactions.py`, add a new endpoint:
    

```python
@router.get("/summary/monthly")
def get_monthly_summary(
    year: int = Query(..., description="Year for summary"),
    month: int = Query(..., ge=1, le=12, description="Month for summary (1-12)"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    return transaction_service.get_monthly_summary(current_user.id, year, month)
```

## 5. Transaction Notes

**Files to modify:**

- `models/transaction.py`
    
- `schemas/transaction.py`
    
- `services/transaction_service.py`
    

**Implementation:**

1. In `models/transaction.py`, add a notes field:
    

```python
notes = Column(Text, nullable=True)
```


2. In `schemas/transaction.py`, add notes field to all schemas:
    

```python
# Add to TransactionBase
notes: Optional[str] = None

# Add to TransactionCreate
notes: Optional[str] = None

# Add to Transaction
notes: Optional[str] = None
```


3. In `transaction_service.py`, update the `create_transaction` method:
    

```python
def create_transaction(self, user_id: int, transaction_data: TransactionCreate) -> Transaction:
    transaction = Transaction(
        user_id=user_id,
        amount=transaction_data.amount,
        type=TransactionType(transaction_data.type),
        category=transaction_data.category,
        description=transaction_data.description,
        date=transaction_data.date,
        notes=transaction_data.notes  # Add this line
    )
    self.db.add(transaction)
    self.db.commit()
    self.db.refresh(transaction)
    return transaction
```

## 6. Update/Delete Transactions

**Files to modify:**

- `services/transaction_service.py`
    
- `routers/transactions.py`
    

**Implementation:**

1. In `transaction_service.py`, add update and delete methods:
    

```python
def update_transaction(self, transaction_id: int, user_id: int, update_data: dict) -> Transaction:
    transaction = self.db.query(Transaction).filter(
        Transaction.id == transaction_id,
        Transaction.user_id == user_id
    ).first()
    
    if not transaction:
        return None
    
    for field, value in update_data.items():
        setattr(transaction, field, value)
    
    self.db.commit()
    self.db.refresh(transaction)
    return transaction

def delete_transaction(self, transaction_id: int, user_id: int) -> bool:
    transaction = self.db.query(Transaction).filter(
        Transaction.id == transaction_id,
        Transaction.user_id == user_id
    ).first()
    
    if not transaction:
        return False
    
    self.db.delete(transaction)
    self.db.commit()
    return True
```


2. In `transactions.py`, add update and delete endpoints:
    

```python
@router.put("/{transaction_id}", response_model=Transaction)
def update_transaction(
    transaction_id: int,
    transaction_data: TransactionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    transaction = transaction_service.update_transaction(
        transaction_id, current_user.id, transaction_data.dict()
    )
    if not transaction:
        raise HTTPException(status_code=404, detail="Transaction not found")
    return transaction

@router.delete("/{transaction_id}")
def delete_transaction(
    transaction_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    success = transaction_service.delete_transaction(transaction_id, current_user.id)
    if not success:
        raise HTTPException(status_code=404, detail="Transaction not found")
    return {"message": "Transaction deleted successfully"}
```

## 7. Authentication Enhancement

**Files to modify:**

- `services/auth_service.py`
    
- `routers/auth.py`
    
- `schemas/user.py`
    

**Implementation:**

1. In `schemas/user.py`, add password change schema:
    

```python
class ChangePasswordRequest(BaseModel):
    current_password: str
    new_password: str
```


2. In `auth_service.py`, add password change method:
    

```python
def change_password(self, user: User, current_password: str, new_password: str) -> bool:
    if not verify_password(current_password, user.password_hash):
        return False
    
    user.password_hash = get_password_hash(new_password)
    self.db.commit()
    return True
```

2. In `auth.py`, add password change endpoint:
    

```python
@router.post("/change-password")
def change_password(
    password_data: ChangePasswordRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    auth_service = AuthService(db)
    success = auth_service.change_password(current_user, password_data.current_password, password_data.new_password)
    if not success:
        raise HTTPException(status_code=400, detail="Current password is incorrect")
    return {"message": "Password changed successfully"}
```
