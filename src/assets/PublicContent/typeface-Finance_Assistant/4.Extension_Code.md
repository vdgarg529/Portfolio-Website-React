## Phase 1 Implementation

### 1. Export Data (CSV/Excel Reports)

Let's add transaction export functionality:

1. First, add these dependencies to `requirements.txt`:
    
```python
pandas==2.0.3
openpyxl==3.1.2
```


2. Create `app/utils/export_utils.py`:
    
```python
import pandas as pd
from io import BytesIO
from app.models.transaction import Transaction
from datetime import date
from typing import List

def export_transactions_to_csv(transactions: List[Transaction]) -> BytesIO:
    data = [{
        'Date': t.date,
        'Amount': t.amount,
        'Type': t.type.value,
        'Category': t.category,
        'Description': t.description
    } for t in transactions]
    
    df = pd.DataFrame(data)
    output = BytesIO()
    df.to_csv(output, index=False)
    output.seek(0)
    return output

def export_transactions_to_excel(transactions: List[Transaction]) -> BytesIO:
    data = [{
        'Date': t.date,
        'Amount': t.amount,
        'Type': t.type.value,
        'Category': t.category,
        'Description': t.description
    } for t in transactions]
    
    df = pd.DataFrame(data)
    output = BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Transactions')
    output.seek(0)
    return output
```


3. Add export endpoint to `app/routers/transactions.py`:
    
```python
from fastapi.responses import StreamingResponse
from app.utils.export_utils import export_transactions_to_csv, export_transactions_to_excel

@router.get("/export/{format}")
def export_transactions(
    format: str,  # "csv" or "excel"
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    type: Optional[str] = Query(None),
    category: Optional[str] = Query(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transactions = transaction_service.get_transactions_export(
        current_user.id, start_date, end_date, type, category
    )
    
    if format == "csv":
        file_data = export_transactions_to_csv(transactions)
        media_type = "text/csv"
        filename = "transactions.csv"
    elif format == "excel":
        file_data = export_transactions_to_excel(transactions)
        media_type = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        filename = "transactions.xlsx"
    else:
        raise HTTPException(status_code=400, detail="Invalid format")
    
    return StreamingResponse(
        file_data,
        media_type=media_type,
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )
```


4. Add the `get_transactions_export` method to `app/services/transaction_service.py`:
    
```python
def get_transactions_export(
    self,
    user_id: int,
    start_date: Optional[date],
    end_date: Optional[date],
    type: Optional[str],
    category: Optional[str]
) -> List[Transaction]:
    query = self.db.query(Transaction).filter(Transaction.user_id == user_id)
    
    if start_date:
        query = query.filter(Transaction.date >= start_date)
    if end_date:
        query = query.filter(Transaction.date <= end_date)
    if type:
        query = query.filter(Transaction.type == TransactionType(type))
    if category:
        query = query.filter(Transaction.category == category)
    
    return query.order_by(Transaction.date.desc()).all()
```


### 2. Budgeting & Analytics

1. Create `app/models/budget.py`:
    
```python
from sqlalchemy import Column, Integer, Float, String, Date, ForeignKey
from sqlalchemy.orm import relationship
from app.db.base import Base

class Budget(Base):
    __tablename__ = "budgets"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    category = Column(String, nullable=False)
    amount = Column(Float, nullable=False)
    month = Column(Date, nullable=False)  # First day of the month
    
    user = relationship("User")
```


2. Create `app/schemas/budget.py`:
    
```python
from pydantic import BaseModel
from datetime import date

class BudgetBase(BaseModel):
    category: str
    amount: float
    month: date

class BudgetCreate(BudgetBase):
    pass

class Budget(BudgetBase):
    id: int
    user_id: int

    class Config:
        from_attributes = True

class BudgetSummary(BaseModel):
    category: str
    budgeted: float
    spent: float
    remaining: float
```


3. Create `app/services/budget_service.py`:
    
```python
from sqlalchemy.orm import Session
from sqlalchemy import func, extract
from datetime import date, datetime
from app.models.budget import Budget
from app.models.transaction import Transaction, TransactionType

class BudgetService:
    def __init__(self, db: Session):
        self.db = db
    
    def create_budget(self, user_id: int, budget_data: BudgetCreate) -> Budget:
        budget = Budget(
            user_id=user_id,
            category=budget_data.category,
            amount=budget_data.amount,
            month=budget_data.month.replace(day=1)
        )
        self.db.add(budget)
        self.db.commit()
        self.db.refresh(budget)
        return budget
    
    def get_budget_summary(self, user_id: int, month: date) -> list:
        # Get all budgets for the month
        budgets = self.db.query(Budget).filter(
            Budget.user_id == user_id,
            Budget.month == month.replace(day=1)
        ).all()
        
        summary = []
        for budget in budgets:
            # Calculate spent amount for the category in the month
            spent = self.db.query(func.coalesce(func.sum(Transaction.amount), 0)).filter(
                Transaction.user_id == user_id,
                Transaction.category == budget.category,
                Transaction.type == TransactionType.EXPENSE,
                extract('year', Transaction.date) == month.year,
                extract('month', Transaction.date) == month.month
            ).scalar()
            
            summary.append({
                "category": budget.category,
                "budgeted": budget.amount,
                "spent": spent,
                "remaining": budget.amount - spent
            })
        
        return summary
```


3. Create `app/routers/budgets.py`:
    

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from datetime import date
from app.db.session import get_db
from app.schemas.budget import Budget, BudgetCreate, BudgetSummary
from app.services.budget_service import BudgetService
from app.services.auth_service import get_current_user
from app.models.user import User

router = APIRouter(prefix="/budgets", tags=["budgets"])

@router.post("/", response_model=Budget)
def create_budget(
    budget_data: BudgetCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    budget_service = BudgetService(db)
    return budget_service.create_budget(current_user.id, budget_data)

@router.get("/summary", response_model=list[BudgetSummary])
def get_budget_summary(
    month: date,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    budget_service = BudgetService(db)
    return budget_service.get_budget_summary(current_user.id, month)
```



### 3. Advanced Search

Enhance the existing transaction search in `app/services/transaction_service.py`:

```python
def get_transactions(
    self,
    user_id: int,
    start_date: Optional[date],
    end_date: Optional[date],
    type: Optional[str],
    category: Optional[str],
    description: Optional[str] = None,  # New parameter
    min_amount: Optional[float] = None,  # New parameter
    max_amount: Optional[float] = None,  # New parameter
    page: int,
    limit: int
) -> PaginatedTransactions:
    query = self.db.query(Transaction).filter(Transaction.user_id == user_id)
    
    if start_date:
        query = query.filter(Transaction.date >= start_date)
    if end_date:
        query = query.filter(Transaction.date <= end_date)
    if type:
        query = query.filter(Transaction.type == TransactionType(type))
    if category:
        query = query.filter(Transaction.category == category)
    if description:
        query = query.filter(Transaction.description.ilike(f"%{description}%"))
    if min_amount is not None:
        query = query.filter(Transaction.amount >= min_amount)
    if max_amount is not None:
        query = query.filter(Transaction.amount <= max_amount)
    
    total = query.count()
    transactions = query.order_by(Transaction.date.desc()).offset((page - 1) * limit).limit(limit).all()
    pages = (total + limit - 1) // limit
    
    return PaginatedTransactions(
        items=transactions,
        total=total,
        page=page,
        pages=pages
    )
```


Update the router in `app/routers/transactions.py` to include the new parameters:

```python
@router.get("/", response_model=PaginatedTransactions)
def get_transactions(
    start_date: Optional[date] = Query(None),
    end_date: Optional[date] = Query(None),
    type: Optional[str] = Query(None),
    category: Optional[str] = Query(None),
    description: Optional[str] = Query(None),  # New
    min_amount: Optional[float] = Query(None),  # New
    max_amount: Optional[float] = Query(None),  # New
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    transaction_service = TransactionService(db)
    return transaction_service.get_transactions(
        current_user.id, start_date, end_date, type, category, 
        description, min_amount, max_amount, page, limit
    )
```





# Phase 2 Implementation: Recurring Transactions & Notifications

Let's continue with Phase 2 features, starting with Recurring Transactions and then Notifications & Alerts.

## 1. Recurring Transactions

### 1.1 Create the Recurring Transaction Model

Create `app/models/recurring_transaction.py`:

```python
from sqlalchemy import Column, Integer, Float, String, Text, Date, DateTime, ForeignKey, Enum, Boolean
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
import enum
from app.db.base import Base

class RecurringFrequency(enum.Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    YEARLY = "yearly"

class RecurringTransaction(Base):
    __tablename__ = "recurring_transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    amount = Column(Float, nullable=False)
    type = Column(Enum(enum.Enum('TransactionType', [('INCOME', 'income'), ('EXPENSE', 'expense')])), nullable=False)
    category = Column(String, nullable=False)
    description = Column(Text, nullable=True)
    frequency = Column(Enum(RecurringFrequency), nullable=False)
    start_date = Column(Date, nullable=False)
    end_date = Column(Date, nullable=True)
    is_active = Column(Boolean, default=True)
    next_occurrence = Column(Date, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User")
```

### 1.2 Create the Schema for Recurring Transactions

Create `app/schemas/recurring_transaction.py`:

```python
from pydantic import BaseModel
from datetime import date, datetime
from enum import Enum

class RecurringFrequency(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    YEARLY = "yearly"

class RecurringTransactionBase(BaseModel):
    amount: float
    type: str  # "income" or "expense"
    category: str
    description: str = None
    frequency: RecurringFrequency
    start_date: date
    end_date: date = None
    is_active: bool = True

class RecurringTransactionCreate(RecurringTransactionBase):
    pass

class RecurringTransaction(RecurringTransactionBase):
    id: int
    user_id: int
    next_occurrence: date
    created_at: datetime

    class Config:
        from_attributes = True
```

### 1.3 Create the Service for Recurring Transactions

Create `app/services/recurring_transaction_service.py`:

```python
from sqlalchemy.orm import Session
from datetime import date, timedelta
from app.models.recurring_transaction import RecurringTransaction, RecurringFrequency
from app.models.transaction import Transaction, TransactionType
from app.schemas.recurring_transaction import RecurringTransactionCreate

class RecurringTransactionService:
    def __init__(self, db: Session):
        self.db = db

    def create_recurring_transaction(self, user_id: int, recurring_data: RecurringTransactionCreate) -> RecurringTransaction:
        # Calculate next occurrence
        next_occurrence = self.calculate_next_occurrence(
            recurring_data.start_date, 
            recurring_data.frequency
        )
        
        recurring_transaction = RecurringTransaction(
            user_id=user_id,
            amount=recurring_data.amount,
            type=TransactionType(recurring_data.type),
            category=recurring_data.category,
            description=recurring_data.description,
            frequency=RecurringFrequency(recurring_data.frequency),
            start_date=recurring_data.start_date,
            end_date=recurring_data.end_date,
            is_active=recurring_data.is_active,
            next_occurrence=next_occurrence
        )
        self.db.add(recurring_transaction)
        self.db.commit()
        self.db.refresh(recurring_transaction)
        return recurring_transaction

    def get_recurring_transactions(self, user_id: int):
        return self.db.query(RecurringTransaction).filter(RecurringTransaction.user_id == user_id).all()

    def generate_transactions_from_recurring(self):
        today = date.today()
        recurring_transactions = self.db.query(RecurringTransaction).filter(
            RecurringTransaction.next_occurrence <= today,
            RecurringTransaction.is_active == True,
            (RecurringTransaction.end_date.is_(None)) | (RecurringTransaction.end_date >= today)
        ).all()

        for recurring in recurring_transactions:
            # Create the transaction
            transaction = Transaction(
                user_id=recurring.user_id,
                amount=recurring.amount,
                type=recurring.type,
                category=recurring.category,
                description=recurring.description,
                date=recurring.next_occurrence
            )
            self.db.add(transaction)

            # Calculate next occurrence
            next_date = self.calculate_next_occurrence(recurring.next_occurrence, recurring.frequency)
            recurring.next_occurrence = next_date

        self.db.commit()

    def calculate_next_occurrence(self, current_date: date, frequency: RecurringFrequency) -> date:
        if frequency == RecurringFrequency.DAILY:
            return current_date + timedelta(days=1)
        elif frequency == RecurringFrequency.WEEKLY:
            return current_date + timedelta(weeks=1)
        elif frequency == RecurringFrequency.MONTHLY:
            # Simple month addition: add one month
            if current_date.month == 12:
                return current_date.replace(year=current_date.year + 1, month=1)
            else:
                return current_date.replace(month=current_date.month + 1)
        elif frequency == RecurringFrequency.YEARLY:
            return current_date.replace(year=current_date.year + 1)
```


### 1.4 Create the Router for Recurring Transactions

Create `app/routers/recurring_transactions.py`:

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.schemas.recurring_transaction import RecurringTransaction, RecurringTransactionCreate
from app.services.recurring_transaction_service import RecurringTransactionService
from app.services.auth_service import get_current_user
from app.models.user import User

router = APIRouter(prefix="/recurring-transactions", tags=["recurring_transactions"])

@router.post("/", response_model=RecurringTransaction)
def create_recurring_transaction(
    recurring_data: RecurringTransactionCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    service = RecurringTransactionService(db)
    return service.create_recurring_transaction(current_user.id, recurring_data)

@router.get("/", response_model=list[RecurringTransaction])
def get_recurring_transactions(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    service = RecurringTransactionService(db)
    return service.get_recurring_transactions(current_user.id)
```


### 1.5 Set Up a Scheduler to Generate Transactions

Add APScheduler to `requirements.txt`:

```python
apscheduler==3.10.1
```


Modify `app/main.py` to start the scheduler:

```python
from apscheduler.schedulers.background import BackgroundScheduler
from app.services.recurring_transaction_service import RecurringTransactionService
from app.db.session import SessionLocal

def generate_recurring_transactions():
    db = SessionLocal()
    try:
        service = RecurringTransactionService(db)
        service.generate_transactions_from_recurring()
    finally:
        db.close()

# Create scheduler
scheduler = BackgroundScheduler()
scheduler.add_job(generate_recurring_transactions, 'cron', hour=0, minute=0)  # Run daily at midnight
scheduler.start()

# Shut down the scheduler when exiting the app
@app.on_event("shutdown")
def shutdown_event():
    scheduler.shutdown()
```

## 2. Notifications & Alerts

### 2.1 Update Configuration

Add email settings to `app/core/config.py`:

```python
class Settings(BaseSettings):
    # ... existing settings ...
    SMTP_SERVER: str = os.getenv("SMTP_SERVER", "smtp.gmail.com")
    SMTP_PORT: int = int(os.getenv("SMTP_PORT", "587"))
    SMTP_USERNAME: str = os.getenv("SMTP_USERNAME", "")
    SMTP_PASSWORD: str = os.getenv("SMTP_PASSWORD", "")
    FROM_EMAIL: str = os.getenv("FROM_EMAIL", "")
```


### 2.2 Create an Email Utility

Create `app/utils/email_utils.py`:

```python
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from app.core.config import settings

def send_email(to_email: str, subject: str, body: str):
    msg = MIMEMultipart()
    msg['From'] = settings.FROM_EMAIL
    msg['To'] = to_email
    msg['Subject'] = subject

    msg.attach(MIMEText(body, 'plain'))

    try:
        server = smtplib.SMTP(settings.SMTP_SERVER, settings.SMTP_PORT)
        server.starttls()
        server.login(settings.SMTP_USERNAME, settings.SMTP_PASSWORD)
        text = msg.as_string()
        server.sendmail(settings.FROM_EMAIL, to_email, text)
        server.quit()
        print(f"Email sent to {to_email}")
    except Exception as e:
        print(f"Failed to send email: {e}")
```

### 2.3 Create Alert Rules Model

Create `app/models/alert_rule.py`:

```python
from sqlalchemy import Column, Integer, String, Float, ForeignKey, Enum
from sqlalchemy.orm import relationship
import enum
from app.db.base import Base

class AlertType(enum.Enum):
    BUDGET_OVERRUN = "budget_overrun"
    LARGE_EXPENSE = "large_expense"

class AlertRule(Base):
    __tablename__ = "alert_rules"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    type = Column(Enum(AlertType), nullable=False)
    threshold = Column(Float, nullable=True)  # For large expense
    category = Column(String, nullable=True)  # For budget overrun

    user = relationship("User")
```

### 2.4 Create Alert Service

Create `app/services/alert_service.py`:

```python
from sqlalchemy.orm import Session
from app.models.alert_rule import AlertRule, AlertType
from app.models.transaction import Transaction, TransactionType
from app.utils.email_utils import send_email
from app.models.user import User

class AlertService:
    def __init__(self, db: Session):
        self.db = db

    def check_budget_overrun(self, user: User, category: str, spent: float, budgeted: float):
        if spent > budgeted:
            subject = f"Budget Overrun Alert for {category}"
            body = f"You have exceeded your budget for {category}. Budgeted: {budgeted}, Spent: {spent}."
            send_email(user.username, subject, body)  # Assuming username is email

    def check_large_expense(self, user: User, amount: float, threshold: float):
        if amount >= threshold:
            subject = "Large Expense Alert"
            body = f"A large expense of {amount} was detected, which is above your threshold of {threshold}."
            send_email(user.username, subject, body)

    def run_alerts(self, user_id: int):
        user = self.db.query(User).filter(User.id == user_id).first()
        alert_rules = self.db.query(AlertRule).filter(AlertRule.user_id == user_id).all()

        for rule in alert_rules:
            if rule.type == AlertType.BUDGET_OVERRUN:
                # This would require integration with budget service
                # For simplicity, we assume we have a method to get spent and budgeted for the category
                pass
            elif rule.type == AlertType.LARGE_EXPENSE:
                # Check recent transactions for large expenses
                recent_large_expenses = self.db.query(Transaction).filter(
                    Transaction.user_id == user_id,
                    Transaction.type == TransactionType.EXPENSE,
                    Transaction.amount >= rule.threshold,
                    Transaction.date >= date.today() - timedelta(days=1)  # Last day
                ).all()
                for transaction in recent_large_expenses:
                    self.check_large_expense(user, transaction.amount, rule.threshold)
```

### 2.5 Integrate Alerts with Transaction Creation

Modify `app/services/transaction_service.py` to trigger alerts when a transaction is created:

```python
from app.services.alert_service import AlertService

class TransactionService:
    # ... existing code ...

    def create_transaction(self, user_id: int, transaction_data: TransactionCreate) -> Transaction:
        transaction = Transaction(
            user_id=user_id,
            amount=transaction_data.amount,
            type=TransactionType(transaction_data.type),
            category=transaction_data.category,
            description=transaction_data.description,
            date=transaction_data.date
        )
        self.db.add(transaction)
        self.db.commit()
        self.db.refresh(transaction)

        # Trigger alerts
        alert_service = AlertService(self.db)
        if transaction.type == TransactionType.EXPENSE:
            alert_service.check_large_expense(transaction.user, transaction.amount, 1000)  # Example threshold
            # Also check for budget overrun if you have budget data

        return transaction
```

### 2.6 Create Alert Router

Create `app/routers/alerts.py`:

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.db.session import get_db
from app.models.alert_rule import AlertRule, AlertType
from app.services.alert_service import AlertService
from app.services.auth_service import get_current_user
from app.models.user import User

router = APIRouter(prefix="/alerts", tags=["alerts"])

@router.post("/large-expense/{threshold}")
def set_large_expense_alert(
    threshold: float,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Check if alert already exists
    existing_alert = db.query(AlertRule).filter(
        AlertRule.user_id == current_user.id,
        AlertRule.type == AlertType.LARGE_EXPENSE
    ).first()
    
    if existing_alert:
        existing_alert.threshold = threshold
    else:
        alert = AlertRule(
            user_id=current_user.id,
            type=AlertType.LARGE_EXPENSE,
            threshold=threshold
        )
        db.add(alert)
    
    db.commit()
    return {"message": "Large expense alert set successfully"}

@router.post("/budget-overrun/{category}")
def set_budget_overrun_alert(
    category: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    # Check if alert already exists
    existing_alert = db.query(AlertRule).filter(
        AlertRule.user_id == current_user.id,
        AlertRule.type == AlertType.BUDGET_OVERRUN,
        AlertRule.category == category
    ).first()
    
    if existing_alert:
        return {"message": "Alert already exists for this category"}
    else:
        alert = AlertRule(
            user_id=current_user.id,
            type=AlertType.BUDGET_OVERRUN,
            category=category
        )
        db.add(alert)
        db.commit()
        return {"message": "Budget overrun alert set successfully"}
```
