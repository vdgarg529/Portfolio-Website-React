### File: `requirements.txt`

**File Purpose**: This file is a manifest that lists all the external Python libraries (dependencies) that your project needs to run. A package manager like `pip` uses this file to install everything correctly.

**Line-by-Line Explanation**:

1. `fastapi==0.104.1`: This line specifies that we need version 0.104.1 of the `FastAPI` library. FastAPI is the modern, high-performance web framework we are using to build our API. It handles all the HTTP routing, request parsing, and response generation.
    
2. `uvicorn[standard]==0.24.0`: Uvicorn is an ASGI server. Think of it as the software that actually runs our FastAPI application, listening for incoming web requests on a port and passing them to our code. The `[standard]` extra installs additional dependencies for better performance.
    
3. `sqlalchemy==2.0.23`: SQLAlchemy is the ORM (Object-Relational Mapper) library. It's a toolkit that lets us interact with our database (like SQLite) using Python classes and objects instead of writing raw SQL queries. This makes our code safer and easier to write.
    
4. `pydantic==2.5.0`: Pydantic is a data validation library. We use it to define the "shape" of our data (schemas). It ensures that when data comes into our API (e.g., from a user registration form), it has the correct fields and data types (e.g., `username` is a string, `password` is a string), automatically throwing errors if the data is invalid.
5. `pydantic-settings==2.1.0`: This is an extension for Pydantic specifically for managing application settings, typically loaded from environment variables. We use it in our `config.py` file.
    
6. `python-jose[cryptography]==3.3.0`: This library provides functions to create and verify JWT (JSON Web Tokens). JWTs are the secure tokens we use for user authentication. The `[cryptography]` extra ensures it uses a secure backend for cryptographic operations.
    
7. `passlib==1.7.4`: Passlib is a library dedicated to password hashing. It provides a simple interface for hashing passwords using various algorithms.
    
8. `bcrypt==4.0.1`: Bcrypt is a specific, very secure algorithm for password hashing. Passlib (the previous library) will use bcrypt under the hood because we configured it to do so in `security.py`.
    
9. `python-multipart==0.0.6`: This library is required by FastAPI to handle HTTP requests that include form data, which is necessary for our file upload endpoints (`/receipts/upload`).
    
10. `pytesseract==0.3.10`: This is a Python wrapper for Tesseract, an OCR (Optical Character Recognition) engine. It allows our program to extract text from images, which is the core functionality for processing receipt images.
    
11. `pdfplumber==0.10.3`: This library is专门 designed to extract text and data from PDF files. We use it to parse bank statement PDFs.
    
12. `pillow==10.0.0`: Pillow is a fork of the Python Imaging Library (PIL). It adds image processing capabilities to Python. `pytesseract` requires Pillow to open and handle image files before performing OCR.
    
13. `pypdf2==3.0.1`: PyPDF2 is another library for working with PDF files. It might be used as a fallback or for different PDF manipulation tasks alongside `pdfplumber`.

### File: `config.py` (app/core/[config.py](https://config.py/))

**File Purpose**: This file centralizes all the configuration settings for our application. Instead of hardcoding sensitive data like secret keys or database URLs into our code, we keep them here. These settings can be easily changed based on the environment (development, production) by using environment variables.

**Line-by-Line Explanation**:

1. `from pydantic_settings import BaseSettings`: Imports the `BaseSettings` class from `pydantic-settings`. This class is the foundation for creating our settings model. It automatically handles reading values from environment variables.
    
2. `import os`: Imports Python's built-in `os` module. This gives us access to operating system functionality, which we need to read environment variables using `os.getenv()`.
    
3. `class Settings(BaseSettings):`: Defines a new class `Settings` that inherits from `BaseSettings`. This class will hold all our configuration fields.
    
4. `DATABASE_URL: str = os.getenv("DATABASE_URL", "sqlite:///./finance_assistant.db")`: Defines a configuration field named `DATABASE_URL`.
    
    - `: str` specifies that this field must be a string.
        
    - `os.getenv("DATABASE_URL", "sqlite:///./finance_assistant.db")` is the default value. It tries to read an environment variable called `DATABASE_URL`. If that variable doesn't exist, it defaults to `"sqlite:///./finance_assistant.db"`.
        
    - `DATABASE_URL` is a connection string that tells SQLAlchemy how to connect to the database. The SQLite string means "use the SQLite database, and create the file `finance_assistant.db` in the current directory."
        
5. `SECRET_KEY: str = os.getenv("SECRET_KEY", "asdfghjkl;")`: Defines the `SECRET_KEY` used for signing JWT tokens.
    
    - It's crucial that this is a long, random, and secret string in production. The default value is just for development and is highly insecure for a real application.
        
6. `ALGORITHM: str = os.getenv("ALGORITHM", "HS256")`: Defines the algorithm used for JWT token signing. `HS256` is a common and secure algorithm.
    
7. `ACCESS_TOKEN_EXPIRE_MINUTES: int = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", "30"))`: Defines how long a JWT token is valid after it's issued.
    
    - `os.getenv(...)` gets the value as a string.
        
    - `int(...)` converts that string to an integer. The default is 30 minutes.
        
8. `ALLOWED_ORIGINS: str = os.getenv("ALLOWED_ORIGINS", "http://localhost:3000,http://localhost:8000")`: Defines which web addresses (origins) are allowed to make requests to our API. This is crucial for CORS (Cross-Origin Resource Sharing). The default allows a frontend running on ports 3000 (common for React) and 8000 to talk to our backend.
    
9. `settings = Settings()`: Creates an instance of the `Settings` class. This `settings` object is imported throughout the application whenever we need access to a configuration value.
    

---

### File: `security.py` (app/core/[security.py](https://security.py/))

**File Purpose**: This file contains the core functions for handling password security. It's responsible for hashing passwords (turning them into a scrambled, irreversible string) and for verifying if a provided password matches a stored hash.

**Line-by-Line Explanation**:

1. `from passlib.context import CryptContext`: Imports the `CryptContext` class from Passlib. This class is a central hub for configuring and using different password hashing schemes.
    
2. `pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")`: Creates an instance of `CryptContext`.
    
    - `schemes=["bcrypt"]` tells Passlib that we want to use the `bcrypt` hashing algorithm. It's considered very secure for passwords.
        
    - `deprecated="auto"` tells Passlib to automatically mark any outdated hashing schemes as deprecated if we were to have multiple schemes in the future.
        
3. `def verify_password(plain_password, hashed_password):`: Defines a function named `verify_password` that takes two arguments: a plain text password from the user login attempt, and a hashed password stored in the database.
    
4. `return pwd_context.verify(plain_password, hashed_password)`: This is the function's body. It uses the Passlib context (`pwd_context`) to verify the password.
    
    - `pwd_context.verify(...)` takes the plain text password, hashes it using the same algorithm and parameters as the stored hash, and compares the results. It returns `True` if they match, `False` if they don't. This is done in a way that is safe from timing attacks.
        
5. `def get_password_hash(password):`: Defines a function named `get_password_hash` that takes a plain text password.
    
6. `return pwd_context.hash(password)`: This is the function's body. It uses the Passlib context to hash the password using the configured algorithm (bcrypt). This hashed value is what should be stored in the database when a user registers or changes their password. **You should never store a plain text password.**
    

---

### File: `main.py`

**File Purpose**: This is the entry point of the application. It's the file you run to start the web server. It creates the FastAPI application instance, sets up global middleware (like CORS), connects all the routers (which define the API endpoints), and defines a couple of basic routes.

**Line-by-Line Explanation**:

1. `from fastapi import FastAPI`: Imports the main `FastAPI` class from the FastAPI library.
    
2. `from fastapi.middleware.cors import CORSMiddleware`: Imports the `CORSMiddleware` class, which we will use to configure Cross-Origin Resource Sharing rules.
    
3. `from app.db.base import Base`: Imports the `Base` class from our project. This is the declarative base for all our SQLAlchemy models.
    
4. `from app.db.session import engine`: Imports the `engine` from our project. The engine is the starting point for any SQLAlchemy application. It represents the core interface to the database.
    
5. `from app.routers import auth, transactions, receipts`: Imports the router objects from the `auth`, `transactions`, and `receipts` modules. These routers contain the definitions for all our API endpoints.
    
6. `from app.core.config import settings`: Imports the `settings` object we created in `config.py` so we can access our configuration.
    
7. `import os`: Imports the `os` module for accessing environment variables later.
    
8. `Base.metadata.create_all(bind=engine)`: This is a crucial line for setting up the database.
    
    - `Base.metadata` contains information about all the tables we defined using our SQLAlchemy models (like `User`, `Transaction`).
        
    - `.create_all(bind=engine)` tells SQLAlchemy to create all those tables in the actual database specified by the `engine`. If the tables already exist, it does nothing. This is a simple way to initialize the database schema.
        
9. `app = FastAPI(title="Personal Finance Assistant", version="1.0.0")`: Creates an instance of the `FastAPI` application. This `app` object is the core of our API. We provide a title and version for the automatically generated documentation.
    
10. `app.add_middleware(...)`: Adds the CORS middleware to our application.
    
    - `CORSMiddleware`: The class of middleware to add.
        
    - `allow_origins=settings.ALLOWED_ORIGINS.split(",")`: This configures which origins are allowed. It takes the `ALLOWED_ORIGINS` string from our settings (e.g., `"http://localhost:3000,http://localhost:8000"`), splits it on the comma, and turns it into a list `["http://localhost:3000", "http://localhost:8000"]`.
        
    - `allow_credentials=True`: Allows browsers to include cookies in requests. Important for authentication in some setups.
        
    - `allow_methods=["*"]`: Allows all HTTP methods (GET, POST, PUT, DELETE, etc.).
        
    - `allow_headers=["*"]`: Allows all HTTP headers in the requests.
        
11. `app.include_router(auth.router)`: This "mounts" the routes defined in the `auth.router` onto our main application. All routes in the `auth` router will be prefixed with `/auth` (as defined in the router itself).
    
12. `app.include_router(transactions.router)`: Includes the transactions router with its prefix `/transactions`.
    
13. `app.include_router(receipts.router)`: Includes the receipts router with its prefix `/receipts`.
    
14. `@app.get("/")`: A decorator that tells FastAPI: "The function right below this handles HTTP GET requests to the root path (`/`)."
    
15. `def read_root():`: The function that handles the root endpoint.
    
16. `return {"message": "Personal Finance Assistant API"}`: When someone visits the root URL, they will receive this JSON response.
    
17. `@app.get("/health")`: Decorator for a GET request to the `/health` path.
    
18. `def health_check():`: Function for the health check endpoint.
    
19. `return {"status": "healthy"}`: Returns a simple JSON indicating the API is running. This is very useful for monitoring and deployment checks.
    
20. `if __name__ == "__main__":`: This is a common Python idiom. The code inside this `if` block will only run if this script is executed directly (e.g., `python main.py`), not if it is imported as a module into another script.
    
21. `import uvicorn`: Imports Uvicorn inside the block, so we only import it if we need to run the server this way.
    
22. `port = int(os.environ.get("PORT", 8000))`: Tries to get the `PORT` environment variable. This is used by many hosting platforms (like Heroku, Render) to tell the application which port to listen on. If the `PORT` variable isn't set, it defaults to `8000`.
    
23. `uvicorn.run(app, host="0.0.0.0", port=port)`: Starts the Uvicorn server.
    
    - `app`: The FastAPI application to run.
        
    - `host="0.0.0.0"`: Tells the server to listen on all public IP addresses. This is necessary for the app to be accessible from outside its own container/machine when deployed.
        
    - `port=port`: Uses the port we determined in the previous line.

### File: `base.py` (app/db/[base.py](https://base.py/))

**File Purpose**: This file creates the base class for all SQLAlchemy ORM models. It's a fundamental setup for SQLAlchemy's declarative system, which allows us to define database tables as Python classes.

**Line-by-Line Explanation**:

1. `from sqlalchemy.ext.declarative import declarative_base`: This imports the `declarative_base` function from SQLAlchemy. This function is used to create a base class for our database models.
    
2. `Base = declarative_base()`: This creates the actual base class that all our database models will inherit from. This base class gives our models the ability to be mapped to database tables and provides metadata about all the tables in our application.
    

### File: `session.py` (app/db/[session.py](https://session.py/))

**File Purpose**: This file sets up the database connection and session management. It creates the SQLAlchemy engine and session factory that will be used throughout the application to interact with the database.

**Line-by-Line Explanation**:

1. `from sqlalchemy import create_engine`: Imports the function to create a database engine. The engine is responsible for connecting to the database.
    
2. `from sqlalchemy.orm import sessionmaker`: Imports the sessionmaker factory, which will create new Session objects.
    
3. `from app.core.config import settings`: Imports our application settings to get the database URL.
    
4. `engine = create_engine(settings.DATABASE_URL, connect_args={"check_same_thread": False})`: Creates the database engine.
    
    - `settings.DATABASE_URL`: The connection string for our database.
        
    - `connect_args={"check_same_thread": False}`: This is specific to SQLite and allows multiple threads to use the same connection. For other databases, this wouldn't be necessary.
        
5. `SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)`: Creates a session factory.
    
    - `autocommit=False`: We want to explicitly control when changes are committed.
        
    - `autoflush=False`: We want to explicitly control when changes are sent to the database.
        
    - `bind=engine`: Associates the session factory with our database engine.
        
6. `def get_db():`: Defines a dependency function that will provide a database session.
    
7. `db = SessionLocal()`: Creates a new session from the factory.
    
8. `try:`: Starts a try block to ensure we properly handle the session.
    
9. `yield db`: Yields the session to the route function that needs it. This is a generator function pattern used by FastAPI for dependencies.
    
10. `finally:`: This block runs after the route function has finished.
    
11. `db.close()`: Closes the database session. This is crucial to prevent database connection leaks.
    

### File: `user.py` (app/models/[user.py](https://user.py/))

**File Purpose**: Defines the User model for the database, representing the structure of the 'users' table.

**Line-by-Line Explanation**:

1. `from sqlalchemy import Column, Integer, String, DateTime`: Imports the column types we need.
    
2. `from sqlalchemy.sql import func`: Imports SQL functions, specifically for getting the current timestamp.
    
3. `from app.db.base import Base`: Imports our base class.
    
4. `class User(Base):`: Defines the User class that inherits from Base.
    
5. `__tablename__ = "users"`: Specifies the name of the database table.
    
6. `id = Column(Integer, primary_key=True, index=True)`: Defines the primary key column.
    
    - `primary_key=True`: Marks this as the primary key.
        
    - `index=True`: Creates an index on this column for faster queries.
        
7. `username = Column(String, unique=True, index=True, nullable=False)`: Defines the username column.
    
    - `unique=True`: Ensures no two users can have the same username.
        
    - `index=True`: Creates an index for faster username lookups.
        
    - `nullable=False`: This field cannot be empty.
        
8. `password_hash = Column(String, nullable=False)`: Stores the hashed password.
    
9. `created_at = Column(DateTime(timezone=True), server_default=func.now())`: Automatically sets the timestamp when a user is created.
    
    - `timezone=True`: Stores the time with timezone information.
        
    - `server_default=func.now()`: Uses the database server's time function as the default.
        

### File: `transaction.py` (app/models/[transaction.py](https://transaction.py/))

**File Purpose**: Defines the Transaction model and TransactionType enum for the database.

**Line-by-Line Explanation**:

1. `from sqlalchemy import Column, Integer, Float, String, Text, Date, DateTime, ForeignKey, Enum`: Imports various column types.
    
2. `from sqlalchemy.sql import func`: Imports SQL functions.
    
3. `from sqlalchemy.orm import relationship`: Imports the relationship function for defining model relationships.
    
4. `import enum`: Imports Python's enum module.
    
5. `from app.db.base import Base`: Imports our base class.
    
6. `class TransactionType(enum.Enum):`: Defines an enumeration for transaction types.
    
    - `INCOME = "income"`: An income transaction.
        
    - `EXPENSE = "expense"`: An expense transaction.
        
7. `class Transaction(Base):`: Defines the Transaction class.
    
8. `__tablename__ = "transactions"`: Specifies the table name.
    
9. `id = Column(Integer, primary_key=True, index=True)`: Primary key column.
    
10. `user_id = Column(Integer, ForeignKey("users.id"), nullable=False)`: Foreign key to the users table.
    
    - `ForeignKey("users.id")`: Creates a foreign key constraint to the id column of the users table.
        
11. `amount = Column(Float, nullable=False)`: The transaction amount.
    
12. `type = Column(Enum(TransactionType), nullable=False)`: The transaction type using our enum.
    
13. `category = Column(String, nullable=False)`: The transaction category.
    
14. `description = Column(Text, nullable=True)`: Optional description of the transaction.
    
    - `nullable=True`: This field can be empty.
        
15. `date = Column(Date, nullable=False)`: The date of the transaction.
    
16. `created_at = Column(DateTime(timezone=True), server_default=func.now())`: Automatic timestamp.
    
17. `user = relationship("User")`: Defines a relationship to the User model.
    
    - This allows us to access the user object associated with a transaction.
        

### File: `receipt.py` (app/models/[receipt.py](https://receipt.py/))

**File Purpose**: Defines the Receipt model for the database.

**Line-by-Line Explanation**:

1. `from sqlalchemy import Column, Integer, String, Text, DateTime, ForeignKey`: Imports column types.
    
2. `from sqlalchemy.sql import func`: Imports SQL functions.
    
3. `from sqlalchemy.orm import relationship`: Imports relationship function.
    
4. `from app.db.base import Base`: Imports base class.
    
5. `class Receipt(Base):`: Defines the Receipt class.
    
6. `__tablename__ = "receipts"`: Specifies the table name.
    
7. `id = Column(Integer, primary_key=True, index=True)`: Primary key column.
    
8. `user_id = Column(Integer, ForeignKey("users.id"), nullable=False)`: Foreign key to users table.
    
9. `file_path = Column(String, nullable=False)`: Path to the uploaded file.
    
10. `parsed_text = Column(Text, nullable=True)`: Text extracted from the receipt.
    
    - `nullable=True`: This can be null if OCR fails or hasn't been performed.
        
11. `uploaded_at = Column(DateTime(timezone=True), server_default=func.now())`: Upload timestamp.
    
12. `user = relationship("User")`: Relationship to User model.
    

### File: `user.py` (app/schemas/[user.py](https://user.py/))

**File Purpose**: Defines Pydantic schemas for user-related data validation and serialization.

**Line-by-Line Explanation**:

1. `from pydantic import BaseModel`: Imports BaseModel for creating schemas.
    
2. `from datetime import datetime`: Imports datetime for timestamp fields.
    
3. `class UserBase(BaseModel):`: Base schema with common fields.
    
    - `username: str`: Username field.
        
4. `class UserCreate(UserBase):`: Schema for creating a user.
    
    - `password: str`: Adds password field for registration.
        
5. `class User(UserBase):`: Schema for returning user data (without password).
    
    - `id: int`: User ID.
        
    - `created_at: datetime`: Account creation timestamp.
        
    - `class Config:`: Configuration for the schema.
        
    - `from_attributes = True`: Allows creating from ORM objects (formerly called ORM mode).
        
6. `class Token(BaseModel):`: Schema for JWT token response.
    
    - `access_token: str`: The JWT token.
        
    - `token_type: str`: The token type (usually "bearer").
        
7. `class TokenData(BaseModel):`: Schema for data embedded in the token.
    
    - `username: str | None = None`: The username from the token.
        

### File: `transaction.py` (app/schemas/[transaction.py](https://transaction.py/))

**File Purpose**: Defines Pydantic schemas for transaction-related data.

**Line-by-Line Explanation**:

1. `from pydantic import BaseModel`: Imports BaseModel.
    
2. `from datetime import date, datetime`: Imports date and datetime types.
    
3. `from enum import Enum`: Imports Enum for creating enums.
    
4. `from typing import Optional`: Imports Optional for nullable fields.
    
5. `class TransactionType(str, Enum):`: String enum for transaction types.
    
    - `INCOME = "income"`
        
    - `EXPENSE = "expense"`
        
6. `class TransactionBase(BaseModel):`: Base schema for transactions.
    
    - `amount: float`: Transaction amount.
        
    - `type: TransactionType`: Income or expense.
        
    - `category: str`: Transaction category.
        
    - `description: Optional[str] = None`: Optional description.
        
    - `date: date`: Transaction date.
        
7. `class TransactionCreate(TransactionBase):`: Schema for creating a transaction.
    
    - Inherits all fields from TransactionBase.
        
8. `class Transaction(TransactionBase):`: Schema for returning transaction data.
    
    - `id: int`: Transaction ID.
        
    - `user_id: int`: User ID who owns the transaction.
        
    - `created_at: datetime`: Creation timestamp.
        
    - `class Config:`: Configuration.
        
    - `from_attributes = True`: ORM mode.
        
9. `class TransactionSummary(BaseModel):`: Schema for category summary.
    
    - `category: str`: Category name.
        
    - `total_amount: float`: Total amount for this category.
        
10. `class DateSummary(BaseModel):`: Schema for date summary.
    
    - `date: date`: The date.
        
    - `total_amount: float`: Total amount for this date.
        
11. `class PaginatedTransactions(BaseModel):`: Schema for paginated transactions.
    
    - `items: list[Transaction]`: List of transactions.
        
    - `total: int`: Total number of transactions.
        
    - `page: int`: Current page number.
        
    - `pages: int`: Total number of pages.
        

### File: `receipt.py` (app/schemas/[receipt.py](https://receipt.py/))

**File Purpose**: Defines Pydantic schemas for receipt-related data.

**Line-by-Line Explanation**:

1. `from pydantic import BaseModel`: Imports BaseModel.
    
2. `from datetime import datetime`: Imports datetime.
    
3. `from typing import Optional`: Imports Optional.
    
4. `class ReceiptBase(BaseModel):`: Base schema for receipts.
    
    - `file_path: str`: Path to the receipt file.
        
5. `class ReceiptCreate(ReceiptBase):`: Schema for creating a receipt.
    
    - Inherits from ReceiptBase.
        
6. `class Receipt(ReceiptBase):`: Schema for returning receipt data.
    
    - `id: int`: Receipt ID.
        
    - `user_id: int`: User ID who uploaded the receipt.
        
    - `parsed_text: Optional[str] = None`: Extracted text (can be null).
        
    - `uploaded_at: datetime`: Upload timestamp.
        
    - `class Config:`: Configuration.
        
    - `from_attributes = True`: ORM mode.
        

### File: `auth_service.py` (app/services/auth_[service.py](https://service.py/))

**File Purpose**: Implements authentication business logic including user registration, authentication, and JWT token handling.

**Line-by-Line Explanation**:

1. `from datetime import datetime, timedelta`: Imports datetime and timedelta for token expiration.
    
2. `from jose import JWTError, jwt`: Imports JWT functions.
    
3. `from fastapi import Depends, HTTPException, status`: Imports FastAPI components.
    
4. `from fastapi.security import OAuth2PasswordBearer`: Imports OAuth2 password bearer flow.
    
5. `from sqlalchemy.orm import Session`: Imports Session for database access.
    
6. `from app.models.user import User`: Imports User model.
    
7. `from app.schemas.user import UserCreate`: Imports UserCreate schema.
    
8. `from app.core.config import settings`: Imports application settings.
    
9. `from app.core.security import verify_password, get_password_hash`: Imports security functions.
    
10. `from app.db.session import get_db`: Imports database session getter.
    
11. `oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")`: Sets up OAuth2 password bearer flow.
    
    - `tokenUrl="auth/login"`: Specifies the endpoint for token retrieval.
        
12. `class AuthService:`: Defines the authentication service class.
    
13. `def __init__(self, db: Session):`: Constructor.
    
    - `self.db = db`: Stores the database session.
        
14. `def register_user(self, user_data: UserCreate) -> User:`: Method to register a new user.
    
15. `existing_user = self.db.query(User).filter(User.username == user_data.username).first()`: Checks if username exists.
    
16. `if existing_user:`: If username already exists.
    
17. `raise ValueError("Username already registered")`: Raises an error.
    
18. `hashed_password = get_password_hash(user_data.password)`: Hashes the password.
    
19. `user = User(username=user_data.username, password_hash=hashed_password)`: Creates a new User object.
    
20. `self.db.add(user)`: Adds user to session.
    
21. `self.db.commit()`: Commits to database.
    
22. `self.db.refresh(user)`: Refreshes to get the new ID.
    
23. `return user`: Returns the created user.
    
24. `def authenticate_user(self, username: str, password: str) -> User | None:`: Method to authenticate user.
    
25. `user = self.db.query(User).filter(User.username == username).first()`: Finds user by username.
    
26. `if not user or not verify_password(password, user.password_hash):`: If user doesn't exist or password doesn't match.
    
27. `return None`: Return None (authentication failed).
    
28. `return user`: Return user (authentication succeeded).
    
29. `def create_access_token(self, data: dict) -> str:`: Method to create JWT token.
    
30. `to_encode = data.copy()`: Copies the data to encode.
    
31. `expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)`: Calculates expiration time.
    
32. `to_encode.update({"exp": expire})`: Adds expiration to payload.
    
33. `encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)`: Encodes the JWT.
    
34. `return encoded_jwt`: Returns the token.
    
35. `def get_current_user(...)`: Dependency function to get current user from token.
    
36. `credentials_exception = HTTPException(...)`: Creates exception for invalid credentials.
    
37. `try:`: Starts try block for JWT decoding.
    
38. `payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])`: Decodes the JWT.
    
39. `username: str = payload.get("sub")`: Extracts username from subject claim.
    
40. `if username is None:`: If no username in token.
    
41. `raise credentials_exception`: Raise error.
    
42. `except JWTError:`: If JWT is invalid.
    
43. `raise credentials_exception`: Raise error.
    
44. `user = db.query(User).filter(User.username == username).first()`: Find user in database.
    
45. `if user is None:`: If user doesn't exist.
    
46. `raise credentials_exception`: Raise error.
    
47. `return user`: Return the user.
    

### File: `transaction_service.py` (app/services/transaction_[service.py](https://service.py/))

**File Purpose**: Implements business logic for transaction-related operations.

**Line-by-Line Explanation**:

1. `from sqlalchemy.orm import Session`: Imports Session for database access.
    
2. `from sqlalchemy import func, and_`: Imports SQL functions and AND operator.
    
3. `from typing import Optional`: Imports Optional for optional parameters.
    
4. `from datetime import date`: Imports date type.
    
5. `from app.models.transaction import Transaction, TransactionType`: Imports Transaction model and enum.
    
6. `from app.schemas.transaction import TransactionCreate, TransactionSummary, DateSummary, PaginatedTransactions`: Imports transaction schemas.
    
7. `class TransactionService:`: Defines the transaction service class.
    
8. `def __init__(self, db: Session):`: Constructor.
    
    - `self.db = db`: Stores database session.
        
9. `def create_transaction(...)`: Method to create a new transaction.
    
10. `transaction = Transaction(...)`: Creates Transaction object from input data.
    
11. `self.db.add(transaction)`: Adds to session.
    
12. `self.db.commit()`: Commits to database.
    
13. `self.db.refresh(transaction)`: Refreshes to get generated ID.
    
14. `return transaction`: Returns the created transaction.
    
15. `def get_transactions(...)`: Method to get filtered and paginated transactions.
    
16. `query = self.db.query(Transaction).filter(Transaction.user_id == user_id)`: Starts query for user's transactions.
    
17. Applies various filters based on input parameters.
    
18. `total = query.count()`: Gets total count of matching transactions.
    
19. `transactions = query.order_by(Transaction.date.desc()).offset((page - 1) * limit).limit(limit).all()`: Applies ordering and pagination.
    
20. `pages = (total + limit - 1) // limit`: Calculates total number of pages.
    
21. `return PaginatedTransactions(...)`: Returns paginated results.
    
22. `def get_category_summary(...)`: Method to get summary by category.
    
23. `query = self.db.query(Transaction.category, func.sum(Transaction.amount).label("total_amount"))`: Query for category sums.
    
24. Applies filters.
    
25. `results = query.group_by(Transaction.category).all()`: Groups by category and gets results.
    
26. `return [TransactionSummary(...) for row in results]`: Returns list of category summaries.
    
27. `def get_date_summary(...)`: Method to get summary by date.
    
28. Similar to category summary but groups by date and orders by date.
    

### File: `receipt_service.py` (app/services/receipt_[service.py](https://service.py/))

**File Purpose**: Implements business logic for receipt processing and OCR integration.

**Line-by-Line Explanation**:

1. `from sqlalchemy.orm import Session`: Imports Session.
    
2. `from app.models.receipt import Receipt`: Imports Receipt model.
    
3. `from app.models.transaction import Transaction, TransactionType`: Imports Transaction model and enum.
    
4. `from app.utils.ocr_parser import extract_text_from_image, parse_receipt_text`: Imports OCR functions.
    
5. `from app.utils.pdf_parser import extract_text_from_pdf, parse_transactions_from_text`: Imports PDF functions.
    
6. `import re`: Imports regex module.
    
7. `from datetime import datetime`: Imports datetime.
    
8. `class ReceiptService:`: Defines the receipt service class.
    
9. `def __init__(self, db: Session):`: Constructor.
    
    - `self.db = db`: Stores database session.
        
10. `def process_receipt(...)`: Method to process an uploaded receipt.
    
11. Determines file type and extracts text using appropriate function.
    
12. `receipt = Receipt(...)`: Creates Receipt object.
    
13. `self.db.add(receipt)`: Adds to session.
    
14. `self.db.commit()`: Commits receipt.
    
15. `self.db.refresh(receipt)`: Refreshes to get ID.
    
16. Tries to parse text and create a transaction.
    
17. `return receipt`: Returns the created receipt.
    
18. `def process_pdf_transactions(...)`: Method to process PDF bank statements.
    
19. Extracts text from PDF.
    
20. Creates a receipt record.
    
21. Parses transactions from text.
    
22. Creates transaction records.
    
23. `return [receipt]`: Returns the receipt.
    

### File: `ocr_parser.py` (app/utils/ocr_[parser.py](https://parser.py/))

**File Purpose**: Provides OCR functionality to extract text from images and parse receipt information.

**Line-by-Line Explanation**:

1. `try:`: Tries to import OCR dependencies.
    
2. `import pytesseract`: Imports Tesseract OCR wrapper.
    
3. `from PIL import Image`: Imports Python Imaging Library.
    
4. `OCR_AVAILABLE = True`: Sets flag indicating OCR is available.
    
5. `pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'`: Sets path to Tesseract executable (Windows specific).
    
6. `except ImportError:`: If imports fail.
    
7. `OCR_AVAILABLE = False`: Sets flag indicating OCR is not available.
    
8. `print("pytesseract not available. OCR functionality disabled.")`: Warns about missing OCR.
    
9. `import re`: Imports regex for text parsing.
    
10. `from datetime import datetime`: Imports datetime.
    
11. `import os`: Imports OS module.
    
12. `def extract_text_from_image(image_path: str) -> str:`: Function to extract text from image.
    
13. Checks if OCR is available.
    
14. `image = Image.open(image_path)`: Opens the image.
    
15. `text = pytesseract.image_to_string(image)`: Performs OCR.
    
16. `return text`: Returns extracted text.
    
17. `def parse_receipt_text(text: str) -> dict:`: Function to parse receipt text.
    
18. `amount_pattern = r'\$?\d+\.\d{2}'`: Regex pattern for monetary amounts.
    
19. `date_pattern = r'\d{1,2}[/-]\d{1,2}[/-]\d{2,4}'`: Regex pattern for dates.
    
20. `amounts = re.findall(amount_pattern, text)`: Finds all amounts in text.
    
21. Converts amounts to floats.
    
22. `total_amount = max(amounts)`: Assumes largest amount is the total.
    
23. `dates = re.findall(date_pattern, text)`: Finds dates in text.
    
24. Tries to parse dates in different formats.
    
25. `category = "Other"`: Default category.
    
26. `category_keywords = {...}`: Mapping of keywords to categories.
    
27. `text_lower = text.lower()`: Converts text to lowercase for case-insensitive matching.
    
28. Loops through categories to find matching keywords.
    
29. `return {...}`: Returns parsed data.
    

### File: `pdf_parser.py` (app/utils/pdf_[parser.py](https://parser.py/))

**File Purpose**: Provides functionality to extract text from PDFs and parse transaction information.

**Line-by-Line Explanation**:

1. `import pdfplumber`: Imports PDF text extraction library.
    
2. `import re`: Imports regex.
    
3. `from datetime import datetime`: Imports datetime.
    
4. `def extract_text_from_pdf(pdf_path: str) -> str:`: Function to extract text from PDF.
    
5. `text = ""`: Initializes empty text.
    
6. `with pdfplumber.open(pdf_path) as pdf:`: Opens PDF file.
    
7. Loops through pages and extracts text.
    
8. `return text`: Returns concatenated text.
    
9. `def parse_transactions_from_text(text: str) -> list[dict]:`: Function to parse transactions from text.
    
10. `transaction_pattern = r'(\d{1,2}/\d{1,2}/\d{2,4})\s+(.*?)\s+(-?\$?\d+\.\d{2})'`: Regex pattern for transaction lines.
    
11. `matches = re.findall(transaction_pattern, text)`: Finds all transaction matches.
    
12. Loops through matches and processes each transaction.
    
13. `transaction_date = datetime.strptime(date_str, '%m/%d/%Y').date()`: Parses date.
    
14. `amount = float(amount_str.replace('$', '').replace(',', ''))`: Cleans and converts amount.
    
15. `transaction_type = "expense" if amount < 0 else "income"`: Determines type based on sign.
    
16. `amount = abs(amount)`: Makes amount positive.
    
17. Determines category based on description keywords.
    
18. `transactions.append({...})`: Adds transaction to list.
    
19. `return transactions`: Returns list of transactions.
    

### File: `auth.py` (app/routers/[auth.py](https://auth.py/))

**File Purpose**: Defines API routes for authentication (registration and login).

**Line-by-Line Explanation**:

1. `from fastapi import APIRouter, Depends, HTTPException, status`: Imports FastAPI components.
    
2. `from fastapi.security import OAuth2PasswordRequestForm`: Imports OAuth2 form.
    
3. `from sqlalchemy.orm import Session`: Imports Session.
    
4. `from app.db.session import get_db`: Imports database session getter.
    
5. `from app.schemas.user import User, UserCreate, Token`: Imports schemas.
    
6. `from app.services.auth_service import AuthService`: Imports auth service.
    
7. `router = APIRouter(prefix="/auth", tags=["auth"])`: Creates router with prefix and OpenAPI tags.
    
8. `@router.post("/register", response_model=User)`: Defines registration endpoint.
    
9. `def register(user_data: UserCreate, db: Session = Depends(get_db)):`: Registration function.
    
10. `auth_service = AuthService(db)`: Creates auth service instance.
    
11. `try:`: Tries to register user.
    
12. `user = auth_service.register_user(user_data)`: Calls service method.
    
13. `return user`: Returns created user.
    
14. `except ValueError as e:`: Catches registration errors.
    
15. `raise HTTPException(status_code=400, detail=str(e))`: Converts to HTTP exception.
    
16. `@router.post("/login", response_model=Token)`: Defines login endpoint.
    
17. `def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):`: Login function.
    
18. `auth_service = AuthService(db)`: Creates auth service.
    
19. `user = auth_service.authenticate_user(form_data.username, form_data.password)`: Authenticates user.
    
20. `if not user:`: If authentication fails.
    
21. `raise HTTPException(...)`: Raises unauthorized error.
    
22. `access_token = auth_service.create_access_token(data={"sub": user.username})`: Creates JWT token.
    
23. `return {"access_token": access_token, "token_type": "bearer"}`: Returns token.
    

### File: `transactions.py` (app/routers/[transactions.py](https://transactions.py/))

**File Purpose**: Defines API routes for transaction operations.

**Line-by-Line Explanation**:

1. Various imports for FastAPI, database, schemas, services, and authentication.
    
2. `router = APIRouter(prefix="/transactions", tags=["transactions"])`: Creates router.
    
3. `@router.post("/", response_model=Transaction)`: Endpoint to create a transaction.
    
4. `@router.get("/", response_model=PaginatedTransactions)`: Endpoint to get transactions with filtering and pagination.
    
5. `@router.get("/summary/category", response_model=list[TransactionSummary])`: Endpoint for category summary.
    
6. `@router.get("/summary/date", response_model=list[DateSummary])`: Endpoint for date summary.
    
7. Each endpoint:
    
    - Uses `Depends(get_db)` for database session
        
    - Uses `Depends(get_current_user)` for authentication
        
    - Creates appropriate service instance
        
    - Calls service method with parameters
        
    - Returns result
        

### File: `receipts.py` (app/routers/[receipts.py](https://receipts.py/))

**File Purpose**: Defines API routes for receipt upload and processing.

**Line-by-Line Explanation**:

1. Various imports for file uploads, UUID generation, etc.
    
2. `router = APIRouter(prefix="/receipts", tags=["receipts"])`: Creates router.
    
3. `@router.post("/upload", response_model=Receipt)`: Endpoint for uploading receipts (images or PDFs).
    
4. `@router.post("/upload-pdf", response_model=list[Receipt])`: Endpoint specifically for PDF bank statements.
    
5. Both endpoints:
    
    - Create upload directory if needed
        
    - Generate unique filename with UUID
        
    - Save uploaded file
        
    - Call appropriate service method
        
    - Return result
        
