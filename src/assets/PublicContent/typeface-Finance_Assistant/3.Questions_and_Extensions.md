### 1. Categorized List of Possible Interview Questions

#### **Architecture & Design Decisions**

- **Why did you choose FastAPI over Flask or Django REST Framework?**
    
    - _What to highlight:_ Async capabilities, automatic API documentation (Swagger/ReDoc), data validation with Pydantic, and dependency injection system.
        
- **Explain your project structure. Why did you separate routers, services, and models?**
    
    - _What to highlight:_ Separation of Concerns (SoC). Routers handle HTTP-specific logic (request/response, status codes). Services contain core business logic (e.g., creating a transaction, parsing a receipt). Models are for database interaction. This makes code easier to test, maintain, and scale.
        
- **Why did you use SQLAlchemy ORM instead of raw SQL?**
    
    - _What to highlight:_ Database agnosticism (easy to switch from SQLite to PostgreSQL), Pythonic object-oriented interface, built-in protection against SQL injection, and easier model relationship management.
        
- **How does your dependency injection (e.g., `Depends(get_db)`) work? What are the benefits?**
    
    - _What to highlight:_ It manages the lifecycle of dependencies (like database sessions), makes testing easier by allowing easy mocking of `get_db` or `get_current_user`, and keeps the code clean and declarative.
        

#### **Security**

- **Walk me through your JWT authentication flow.**
    
    - _What to highlight:_ User logs in -> server verifies credentials -> server creates a signed JWT (containing a `sub` [subject] and expiry) -> client stores token and sends it in the `Authorization: Bearer <token>` header -> protected endpoints use the `get_current_user` dependency to validate the token and fetch the user from the DB.
        
- **Why did you use bcrypt for password hashing?**
    
    - _What to highlight:_ It's a slow hashing algorithm designed to be computationally expensive, which mitigates brute-force attacks even if the password hash database is leaked.
        
- **How do you protect your endpoints?**
    
    - _What to highlight:_ The `get_current_user` dependency is used in route functions. If the token is invalid or missing, the dependency raises an HTTP exception, preventing access to the core logic.
        
- **What is in your JWT payload? Why not store the user ID instead of the username?**
    
    - _What to highlight:_ It contains `sub` (username) and `exp` (expiry). Storing a username is common and works. If you used the ID, you could explain that it's immutable, whereas a username could theoretically change (though your app doesn't allow it), making the token invalid.
        

#### **Testing**

- **How would you write unit tests for the `TransactionService.get_category_summary` method?**
    
    - _What to highlight:_ You would use a testing database (or SQLite in-memory), create a test user, insert several test transactions with known amounts and categories, call the method, and assert that the returned totals match the expected sums. You'd use pytest and likely fixtures for the DB session and test data.
        
- **How would you mock the external Tesseract OCR dependency in a test for `ReceiptService.process_receipt`?**
    
    - _What to highlight:_ You would use `unittest.mock.patch` to mock the `extract_text_from_image` function. Your mock would return a predefined string of text, allowing you to test the parsing and database logic without needing a real image file or Tesseract installed.
        
- **What would you test for the `/login` endpoint?**
    
    - _What to highlight:_ A test for successful login (returns 200 and a token), a test for invalid username (returns 401), a test for invalid password (returns 401).
        

#### **OCR & PDF Parsing**

- **What are the limitations of your current OCR implementation?**
    
    - _What to highlight:_ Accuracy is highly dependent on image quality (blurry, dark, angled receipts will fail). The regex for date/amount parsing is brittle and might fail on differently formatted receipts. It doesn't handle non-English text.
        
- **Why did you choose pytesseract and pdfplumber?**
    
    - _What to highlight:_ Pytesseract is the standard Python wrapper for the powerful Tesseract-OCR engine. Pdfplumber is more feature-rich for PDF text extraction than alternatives like PyPDF2, offering better precision and access to character-level data.
        
- **How would you improve the accuracy of the receipt parsing?**
    
    - _What to highlight:_ Pre-processing images (e.g., using OpenCV for scaling, grayscaling, thresholding). Using more advanced NLP techniques or ML models (like spaCy) instead of just regex for text parsing. Considering a commercial OCR API (Google Vision, AWS Textract) for higher accuracy, though at a cost.
        

#### **Database**

- **Explain the relationships between your User, Transaction, and Receipt models.**
    
    - _What to highlight:_ A `User` has a one-to-many relationship with both `Transaction` and `Receipt` (a user can have many transactions and many receipts). A `Receipt` could be loosely linked to a `Transaction` through the user and date/amount, but you don't have a formal foreign key between them, which is a valid design choice.
        
- **If the number of transactions grew to millions, what performance issues might you face?**
    
    - _What to highlight:_ The `GET /transactions/` endpoint with pagination would still be fine. The summary endpoints (`/summary/category`) doing `GROUP BY` on a large table could become slow. **Solution:** Adding database indexes on `user_id`, `date`, and `category` would be the first and most critical step.
        

#### **Error Handling & Logging**

- **How do you handle errors in your application?**
    
    - _What to highlight:_ You use HTTP exceptions (e.g., `HTTPException(status_code=404)`) in your routers. You also have try-except blocks in your OCR/PDF utils that convert library exceptions into more meaningful ones. However, you could mention that a next step would be to implement a global exception handler using FastAPI's `@app.exception_handler` to format all errors consistently.
        
- **How do you track what's happening in your app? Where are the logs?**
    
    - _What to highlight:_ (This is a trick question – your current code doesn't have logging!). This is a great opportunity to suggest an improvement: "Currently, the application relies on print statements, which is a limitation. For production, I would integrate the Python `logging` module to log events like failed OCR attempts, user logins, and errors to both the console and files for debugging."
        

#### **Deployment & Performance**

- **How would you deploy this application?**
    
    - _What to highlight:_ Containerize it with Docker (a Dockerfile for the Python app). Use a production ASGI server like Uvicorn with Gunicorn. Use a proper database like PostgreSQL. Use a reverse proxy like Nginx. Orchestrate it with Docker Compose or deploy it to a cloud platform like Heroku, Render, or AWS ECS.
        
- **What would happen if 100 users tried to upload large PDFs at the same time?**
    
    - _What to highlight:_ The synchronous PDF parsing would block the event loop, making the entire application unresponsive. **Solution:** The parsing is a CPU-intensive task that should be offloaded to a background worker queue (e.g., Celery with Redis/RabbitMQ). The endpoint would quickly acknowledge the upload and return a `202 Accepted` with a task ID, and the worker would process the file in the background.
        

---

### 2. Feature Extension Ideas

1. **Budgeting & Analytics:** Set monthly budgets for categories and view reports.
    
2. **Bank API Integration:** Automatically import transactions via Plaid or Yodlee.
    
3. **Advanced Search:** Search transactions by description, amount range, etc.
    
4. **Export Data:** Generate and download CSV/Excel reports of transactions.
    
5. **Recurring Transactions:** Define templates for monthly subscriptions/bills.
    
6. **Notifications & Alerts:** Email/SMS alerts for large expenses or budget overruns.
    
7. **Multi-Currency Support:** Handle transactions in different currencies.
    
8. **Receipt Cloud Storage:** Store receipts on S3/Google Cloud Storage instead of local disk.
    
9. **Improved Categorization:** Train a simple ML model to categorize transactions based on description.
    
10. **Multi-User / Groups:** Allow households to share a finance workspace.
    

---

### 3. High-Level Implementation Roadmap for Key Extensions

#### **1. Budgeting & Analytics**

- **Technologies:** Same stack (FastAPI, SQLAlchemy). Charting library for the frontend (e.g., Chart.js, D3).
    
- **Database Changes:** New `Budget` table: `id`, `user_id`, `category`, `month`, `year`, `amount`.
    
- **API Modifications:**
    
    - `POST /budgets/` to create a budget for a category and time period.
        
    - `GET /analytics/spending-vs-budget?month=11&year=2023` would join the `Transaction` and `Budget` tables to return a comparison.
        
- **Steps:**
    
    1. Create `Budget` model and Pydantic schemas.
        
    2. Create a `BudgetService` with CRUD methods.
        
    3. Add new router endpoints for budgets and analytics.
        
    4. (Frontend) Create dashboard components to display charts and progress bars.
        

#### **2. Bank API Integration (using Plaid)**

- **Technologies:** Plaid Python SDK.
    
- **Design Changes:** This is a major feature. You need a flow to link a bank account.
    
- **Database Changes:** New `BankConnection` table to store the user's Plaid `access_token`.
    
- **API Modifications:**
    
    - `POST /bank/link` - Creates a Plaid Link token to initialize the frontend widget.
        
    - `POST /bank/callback` - Handles the public token exchange from Plaid to get a permanent `access_token`, which is stored in the DB.
        
    - `POST /bank/sync` - Triggers a fetch of new transactions from Plaid for a user and creates them in the database.
        
- **Steps:**
    
    1. Create Plaid account and get API keys.
        
    2. Implement the backend endpoints for the Link flow.
        
    3. Create a background task (e.g., with Celery) to periodically call Plaid's transactions/sync endpoint for all connected users and import new transactions.
        

#### **3. Background Worker for File Processing**

- **Technologies:** Celery, Redis (as the message broker).
    
- **Design Changes:** Decouple the HTTP request from the heavy PDF/OCR processing.
    
- **API Modifications:**
    
    - The `POST /receipts/upload` endpoint would now: a) save the file, b) queue a Celery task (e.g., `process_receipt_task.delay(user_id, file_path)`), c) return immediately with a `task_id`.
        
    - New `GET /tasks/{task_id}` endpoint to check the status of the background task.
        
- **Steps:**
    
    1. Install and run Redis.
        
    2. Install Celery and create a `celery_app.py`.
        
    3. Refactor `ReceiptService.process_receipt` logic into a Celery task.
        
    4. Modify the upload endpoint to call the task asynchronously.
        

#### **4. Cloud Storage for Receipts**

- **Technologies:** `boto3` library for AWS S3, or similar for other providers.
    
- **Design Changes:** The `file_path` in the `Receipt` model would become a URL.
    
- **Implementation:**
    
    1. Create an S3 bucket and IAM user with write access.
        
    2. In `receipt_service.py`, replace the code that saves the file locally with a call to `s3.upload_fileobj(file.file, bucket_name, filename)`.
        
    3. Store the generated public URL (e.g., `https://my-bucket.s3.region.amazonaws.com/filename.jpg`) in the `file_path` field.
        

---

### 4. Pitfalls and Challenges to Be Aware Of

- **Don't be defensive about your code's limitations.** Frame them as "known areas for improvement" or "the next steps I had planned." This shows self-awareness and foresight.
    
    - _Example:_ "I'm aware the regex parsing is a bit brittle. The next step would be to improve it with more robust pattern matching or even a simple ML model."
        
- **Don't suggest overly complex extensions.** Keep your implementation ideas realistic and scoped to a reasonable timeframe. Suggesting a "simple ML model" is better than saying "I'd build a full deep learning vision system."
    
- **Emphasize Security and Performance.** When discussing extensions like Bank Integration or background workers, always mention the security implications (handling sensitive tokens) and performance benefits (not blocking the server).
    
- **You don't have to have all the answers.** If they ask a deeply specific question about a technology you haven't used (e.g., "How would you configure the Celery worker autoscaling on Kubernetes?"), it's okay to say, "I haven't had direct experience with that yet, but my approach would be to research the official documentation and best practices for...


