# Overloading and Overriding in C++

## 1. Detailed Notes

### Introduction
- **Overloading and Overriding** are ways to achieve **polymorphism** in C++.  
- **Polymorphism** = "many forms", allows the same function/operator name to behave differently based on context.  
- Two main types:
  1. **Compile-Time Polymorphism (Early Binding)** → Overloading (constructor, function, operator).  
  2. **Runtime Polymorphism (Late Binding)** → Overriding using virtual functions.  

---

### Compile-Time Overloading

#### 1. Constructor Overloading
- A class can have **multiple constructors** with different parameter lists.  
- Helps create objects in different ways.  

```cpp
class Student {
public:
    Student() { cout << "Default constructor\n"; }
    Student(string name) { cout << "Name: " << name << endl; }
    Student(string name, int age) { cout << "Name: " << name << ", Age: " << age << endl; }
};


```


#### 2. Function Overloading

- Functions with the **same name** but **different parameter lists** (number or type).
    
- Resolved by compiler at **compile time**.

```cpp
class Math {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
};
```


#### 3. Operator Overloading

- Allows operators (`+`, `-`, `==`, etc.) to work with **user-defined types**.
    
- Example: Overloading `+` for complex numbers.

```cpp
class Complex {
    int real, imag;
public:
    Complex(int r=0, int i=0) : real(r), imag(i) {}
    Complex operator+(const Complex& c) {
        return Complex(real + c.real, imag + c.imag);
    }
    void display() { cout << real << " + " << imag << "i\n"; }
};

```


### Runtime Overloading (Overriding)

#### 1. Function Overriding

- A **derived class function** with the **same signature** as a base class function.
    
- Base version is **redefined** in the derived class.

```cpp
class Animal {
public:
    void sound() { cout << "Animal makes sound\n"; }
};

class Dog : public Animal {
public:
    void sound() { cout << "Dog barks\n"; }
};

```

#### 2. Virtual Functions

- To achieve **runtime polymorphism**, declare base class function as `virtual`.
    
- Decides at **runtime** which version to call (late binding).
```cpp
class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
};

int main() {
    Animal* a = new Dog();
    a->sound();  // Calls Dog’s version
    return 0;
}

```

## 2. Definitions

- **Overloading:** Same name, different signatures. Happens at compile time.
    
- **Overriding:** Redefining base class function in derived class with same signature. Happens at runtime.
    
- **Virtual Function:** A base class function declared with `virtual` keyword that supports overriding.
    
- **Compile-Time Polymorphism:** Function/operator/constructor overloading resolved at compile time.
    
- **Runtime Polymorphism:** Function overriding resolved at runtime using virtual functions.
    

---

## 3. Key Points to Remember

- Overloading → **different parameter list**, same name.
    
- Operator overloading allows user-defined classes to use operators.
    
- Overriding → same signature, base + derived relationship required.
    
- Virtual keyword enables **dynamic dispatch**.
    
- Without `virtual`, base class pointer always calls base version.
    

---

## 4. ASCII Concept Map

```lua
Polymorphism
   |
   +-- Compile-Time (Early Binding)
   |       |-- Constructor Overloading
   |       |-- Function Overloading
   |       |-- Operator Overloading
   |
   +-- Runtime (Late Binding)
           |-- Function Overriding
           |-- Virtual Functions

```
---

## 5. Real World Example

- **Overloading:**  
    Example: A calculator app with multiple `add()` functions — integers, doubles, arrays.
    
- **Overriding:**  
    Example: A base class `Payment` with `pay()`.
    
    - `CreditCard::pay()` processes card payments.
        
    - `UPI::pay()` processes UPI payments.  
        Depending on the payment type (runtime), correct method is called.
        

---

## 6. Questions with Answers

### Theory

1. **Q:** What is function overloading?  
    **A:** Defining multiple functions with the same name but different parameter lists.
    
2. **Q:** What is operator overloading used for?  
    **A:** To extend the meaning of operators (`+`, `-`, `==`, etc.) for user-defined types like classes.
    
3. **Q:** What is function overriding?  
    **A:** Redefining a base class function in a derived class with the same signature.
    
4. **Q:** Which polymorphism type uses virtual functions?  
    **A:** Runtime polymorphism (late binding).
    
5. **Q:** Can constructors be virtual?  
    **A:** No, constructors cannot be virtual, but destructors can.
    

---

### Coding

6. **Q:** Write a program to demonstrate function overloading.
    

```cpp
#include <iostream>
using namespace std;

class Print {
public:
    void show(int x) { cout << "Integer: " << x << endl; }
    void show(double y) { cout << "Double: " << y << endl; }
    void show(string s) { cout << "String: " << s << endl; }
};

int main() {
    Print p;
    p.show(10);
    p.show(3.14);
    p.show("Hello");
    return 0;
}

```

---

7. **Q:** Demonstrate operator overloading for subtraction.
    

```cpp
#include <iostream>
using namespace std;

class Complex {
    int real, imag;
public:
    Complex(int r=0, int i=0) : real(r), imag(i) {}
    Complex operator-(const Complex& c) {
        return Complex(real - c.real, imag - c.imag);
    }
    void display() { cout << real << " + " << imag << "i\n"; }
};

int main() {
    Complex c1(5, 3), c2(2, 1);
    Complex c3 = c1 - c2;
    c3.display();
    return 0;
}

```

---

8. **Q:** Show function overriding without virtual keyword.
    

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void display() { cout << "Base display\n"; }
};

class Derived : public Base {
public:
    void display() { cout << "Derived display\n"; }
};

int main() {
    Base* b = new Derived();
    b->display();  // Base version called
    return 0;
}

```

---

9. **Q:** Show function overriding with virtual keyword.
    

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void display() { cout << "Base display\n"; }
};

class Derived : public Base {
public:
    void display() override { cout << "Derived display\n"; }
};

int main() {
    Base* b = new Derived();
    b->display();  // Derived version called
    return 0;
}

```

---

10. **Q:** Write program to overload `==` operator to compare objects.
    

```cpp
#include <iostream>
using namespace std;

class Person {
    int age;
public:
    Person(int a) : age(a) {}
    bool operator==(const Person& p) {
        return age == p.age;
    }
};

int main() {
    Person p1(20), p2(20), p3(25);
    cout << (p1 == p2 ? "Equal" : "Not Equal") << endl;
    cout << (p1 == p3 ? "Equal" : "Not Equal") << endl;
    return 0;
}

```

---

## 7. Multiple Choice Questions (MCQs)

1. Function overloading is resolved at:  
    a) Runtime  
    b) Compile time  
    c) Link time  
    d) None  
    **Answer:** b) Compile time
    
2. Which of these cannot be overloaded?  
    a) +  
    b) -  
    c) ::  
    d) ==  
    **Answer:** c) ::
    
3. Which keyword enables runtime polymorphism?  
    a) virtual  
    b) override  
    c) overload  
    d) polymorph  
    **Answer:** a) virtual
    
4. Which type of polymorphism is achieved by function overriding?  
    a) Compile-time  
    b) Runtime  
    c) Both  
    d) None  
    **Answer:** b) Runtime
    
5. Which function type cannot be virtual?  
    a) Normal function  
    b) Constructor  
    c) Destructor  
    d) Static function  
    **Answer:** b) Constructor
    
6. Operator overloading provides:  
    a) Code reusability  
    b) Compile-time polymorphism  
    c) Both a and b  
    d) None  
    **Answer:** c) Both a and b
    
7. Function overriding requires:  
    a) Different function name  
    b) Same function signature in base and derived  
    c) Different return type  
    d) None  
    **Answer:** b) Same function signature in base and derived
    
8. Which binding is used in function overloading?  
    a) Early  
    b) Late  
    c) Hybrid  
    d) None  
    **Answer:** a) Early
    
9. If virtual keyword is not used, overriding falls back to:  
    a) Compile-time polymorphism  
    b) Runtime polymorphism  
    c) Operator overloading  
    d) None  
    **Answer:** a) Compile-time polymorphism
    
10. Which of these can be overloaded?  
    a) new/delete  
    b) []  
    c) ()  
    d) All of the above  
    **Answer:** d) All of the above