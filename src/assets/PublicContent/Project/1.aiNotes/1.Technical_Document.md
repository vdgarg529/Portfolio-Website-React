### **Project: AI-Powered Personal Knowledge Base (RAG Application)**

#### **1. High-Level Overview**

This is a **Retrieval-Augmented Generation (RAG)** backend API built with **FastAPI**. It serves as a personal note-taking and knowledge retrieval system. Users can store notes, and the system intelligently retrieves and summarizes relevant information from their personal collection using Semantic Search and a Large Language Model (LLM).

**Core Value Proposition:** To provide users with a "second brain" that not only stores their notes but understands their content, allowing for powerful querying and insight generation.

**Tech Stack:**

- **Framework:** FastAPI (for async, RESTful endpoints with automatic docs)
    
- **Auth:** JWT Tokens (via `python-jose`), Password Hashing (bcrypt via `passlib`)
    
- **Vector Database:** ChromaDB (local, persistent mode for storing note embeddings)
    
- **Embeddings:** `all-MiniLM-L6-v2` model from `sentence-transformers` (local, offline)
    
- **LLM:** Google's Gemini 1.5 Flash API (for generating summaries)
    
- **Relational Database:** SQLite with SQLAlchemy ORM (for user management)
    
- **Other:** Pydantic (for data validation and settings management), ReportLab (for PDF generation)
    

---

#### **2. Detailed Architecture & Component Breakdown**

##### **`main.py` - The API Gateway**

- **Purpose:** The entry point of the application. Defines all HTTP endpoints and orchestrates interactions between services.
    
- **Key Features:**
    
    - Configures CORS to allow frontend requests.
        
    - Initializes the SQL database (`Base.metadata.create_all`).
        
    - Uses FastAPI's dependency injection (`Depends`) for JWT authentication on protected routes.
        
    - Heavily relies on `asyncio.to_thread` to handle synchronous operations (like ChromaDB calls) without blocking the async event loop.
        
- **Key Endpoints:**
    
    - **Auth:** `POST /register`, `POST /login`
        
    - **Notes (CRUD + Query):** `POST /notes/add`, `POST /notes/query`, `GET /notes/all`, `PUT /notes/edit`, `DELETE /notes/delete`, `GET /notes/check`
        
    - **Utility:** `GET /notes/download` (PDF export), `GET /health`
        

##### **`app/models.py` - Data Schemas**

- **Purpose:** Defines Pydantic models for HTTP request/response validation and the core `NoteMetadata` model.
    
- **Key Models:**
    
    - `RegisterRequest`, `LoginRequest`: For auth flows.
        
    - `NoteRequest`, `QueryRequest`, `DeleteNoteRequest`, `EditNoteRequest`: For note operations.
        
    - **`NoteMetadata`:** **Crucial model.** Defines the structure of data stored in ChromaDB. Uses `default_factory` to automatically generate a UUID `id` and ISO `timestamp` for every note. This metadata is stored alongside the text embedding.
        

##### **`app/services/` - Core Business Logic**

- **`auth.py` - Authentication Service**
    
    - **Purpose:** Handles all security concerns.
        
    - **Key Functions:**
        
        - `verify_password`, `get_password_hash`: Uses `bcrypt` for secure password hashing and verification.
            
        - `create_access_token`: Creates JWTs signed with a secret key (`HS256`), containing the user ID (`sub`) and an expiration time.
            
        - `get_current_user`: A FastAPI dependency that validates incoming JWT tokens on protected routes and extracts the `user_id`. This `user_id` is the primary key for data isolation.
            
- **`db.py` - SQL Database Layer**
    
    - **Purpose:** Manages connection to the SQLite database for user data.
        
    - **Key Setup:** SQLAlchemy `engine`, `SessionLocal` factory, and declarative `Base`.
        
    - **Key Model:** `User` class, which defines the structure of the `users` table (id, email, password_hash, created_at). The `Note` model is commented out, indicating that all note content is stored in ChromaDB, not SQL.
        
- **`embedding_service.py` - Embedding Generation**
    
    - **Purpose:** Converts text into numerical vector representations (embeddings).
        
    - **Key Feature:** Loads the `all-MiniLM-L6-v2` model **once at startup**. The `get_embedding(text)` function then uses this pre-loaded model to encode text, ensuring high performance.
        
- **`chroma_service.py` - Vector Database Management (THE CORE)**
    
    - **Purpose:** All interactions with the ChromaDB vector store. This is where the "magic" of semantic search happens.
        
    - **Key Setup:** Initializes a persistent Chroma client that stores data in `./chroma_db`.
        
    - **Data Isolation:** **Critical Feature.** Creates a **separate collection for each user** (`f"user_{user_id}_notes"`). This ensures users can only ever access their own notes.
        
    - **Key Functions:**
        
        - `add_note`: Generates an embedding for the text, creates a `NoteMetadata` object, and stores everything in the user's collection.
            
        - `query_notes`: Generates an embedding for the query, performs a similarity search in the user's collection, and returns results with a similarity score > 0.5.
            
        - `get_all_notes_chroma`, `has_notes`, `delete_note`, `edit_note`: Full CRUD operations on the vector store.
            
- **`llm_utils.py` - LLM Integration Service**
    
    - **Purpose:** Communicates with the Gemini API to generate intelligent summaries based on retrieved notes.
        
    - **Key Function:** `generate_summary(texts: list[str]) -> str`
        
        - Takes a list of note texts from the search results.
            
        - Constructs a precise prompt instructing the LLM to act as an "expert note summarizer."
            
        - Makes an async HTTP request to the Gemini API with robust error handling for HTTP errors and malformed responses.
            
        - Returns a concise summary connecting themes across the notes.
            

---

#### **3. Critical Workflows & Data Flow**

1. **User Registration:**  
    `main.py` -> `auth.get_password_hash` -> `db.SessionLocal` -> User is saved to SQLite -> JWT token is returned.
    
2. **Adding a Note:**  
    `POST /notes/add` -> Auth validates JWT -> `chroma_service.add_note(user_id, text)` -> `embedding_service.get_embedding(text)` -> Embedding + `NoteMetadata` are stored in the user's Chroma collection.
    
3. **Querying Notes (The RAG Pipeline):**  
    `POST /notes/query` -> Auth validates JWT -> `chroma_service.query_notes(user_id, query)` -> `embedding_service.get_embedding(query)` -> Chroma performs similarity search -> Returns top matching notes -> `llm_utils.generate_summary(matching_note_texts)` -> Returns summary + results to user.
    

---

#### **4. Key Technical Decisions & Trade-offs**

- **ChromaDB in Persistent Mode:** Chosen for simplicity and to avoid external dependencies. **Trade-off:** Horizontal scaling is challenging. A cloud-based vector DB (Pinecone, Weaviate) would be needed for a large-scale application.
    
- **Local Embedding Model:** Chosen for data privacy, cost savings, and offline capability. **Trade-off:** Requires more local compute resources and is less powerful than larger API-based models (OpenAI text-embedding-3).
    
- **SQL for Users, Chroma for Notes:** A hybrid database approach. User auth data is structured and fits well in SQL. Note content is unstructured and requires semantic search, which is perfect for a vector DB.
    
- **Extensive Use of `asyncio.to_thread`:** Necessary because the `sentence-transformers` and ChromaDB libraries are synchronous. This prevents them from blocking the async server but adds complexity. A fully async stack would be more performant.
    

#### **5. Security Summary**

- **Passwords:** Hashed with bcrypt (salted and slow).
    
- **Auth:** Stateless JWT tokens. The secret key (`SECRET_KEY`) must be properly managed (e.g., via environment variables) in production.
    
- **Data Isolation:** The primary security mechanism is ensuring the `user_id` from the validated JWT is the _only_ key used to access their specific Chroma collection. A user cannot access another user's data.
    
- **API Keys:** The Gemini API key is loaded from a `.env` file, which is a good practice for development.
    

#### **6. Potential Improvements / Interview Discussion Points**

- **Secret Management:** `SECRET_KEY` and `GEMINI_API_KEY` are hardcoded/loaded from a file. Should use a proper secrets vault (e.g., AWS Secrets Manager, HashiCorp Vault) or at least environment variables in production.
    
- **Error Handling:** More specific HTTP status codes and structured error responses could be implemented.
    
- **Testing:** How would you unit test the `auth` module? How would you mock the ChromaDB and Gemini API for integration tests?
    
- **Scalability:** As mentioned, the persistent ChromaDB is a bottleneck. How would you architect this to scale? (Answer: Use a client-server vector DB, introduce Redis for caching common queries, etc.)
    
- **Advanced RAG:** Could implement chunking, more sophisticated metadata filtering, and hybrid search (keyword + semantic).
    

---