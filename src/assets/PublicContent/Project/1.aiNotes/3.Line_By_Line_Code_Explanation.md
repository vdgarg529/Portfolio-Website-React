# Codebase Explanation: AI-Powered Note-Taking Application

## Executive Summary

- **Purpose**: A FastAPI-based note-taking application with AI-powered search and summarization capabilities
    
- **Core Features**: User authentication, CRUD operations for notes, semantic search, AI summarization, PDF export
    
- **Data Flow**: User notes → ChromaDB vector storage → Semantic search → Gemini API summarization
    
- **State Management**: SQLite for user data, ChromaDB for vectorized notes, JWT for session management
    
- **Key Dependencies**: FastAPI, ChromaDB, SentenceTransformers, Google Gemini API, SQLAlchemy
    
- **Authentication**: JWT-based authentication with password hashing
    
- **AI Integration**: Uses Gemini API for note summarization and sentence embeddings for semantic search


## Map of the Codebase


|File|Purpose|
|---|---|
|`main.py`|FastAPI application entry point with all route handlers|
|`models.py`|Pydantic models for request/response validation|
|`auth.py`|JWT authentication utilities and password hashing|
|`chroma_service.py`|ChromaDB vector database operations for notes|
|`db.py`|SQLAlchemy database models and configuration|
|`embedding_service.py`|Text embedding generation using SentenceTransformers|
|`llm_utils.py`|Gemini AI API integration for note summarization|
|`inspect_chroma_db.py`|Utility script to inspect ChromaDB contents|
|`test_gemini_connection.py`|Test script for Gemini API connectivity|

## Dependency & Call Graph

```text
main.py → 
  ├── auth.py (for authentication)
  ├── chroma_service.py (for note operations)
  ├── db.py (for user database)
  ├── llm_utils.py (for AI summarization)
  └── embedding_service.py (indirectly via chroma_service)

chroma_service.py → 
  ├── embedding_service.py (for text embeddings)
  └── models.py (for NoteMetadata)

llm_utils.py → 
  └── External Gemini API
```

## Per-File Deep Dive

### `app/models.py`

**Purpose**: Defines Pydantic models for request/response validation and data structures.

**Key Imports & Globals**:

- `pydantic.BaseModel`, `Field` for model definition
    
- `uuid` for ID generation
    
- `datetime` for timestamp handling
    

**Public API**:

- `RegisterRequest`: User registration data
    
- `LoginRequest`: User login credentials
    
- `NoteRequest`: New note creation data
    
- `QueryRequest`: Search query input
    
- `NoteMetadata`: Note structure with auto-generated fields
    
- `DeleteNoteRequest`: Note deletion request
    
- `EditNoteRequest`: Note update request
    

**LINE-BY-LINE EXPLANATION**:

```python
from pydantic import BaseModel, Field
from typing import Optional
import uuid
from datetime import datetime

class RegisterRequest(BaseModel):
    email: str
    password: str
```
- L1-4: Import dependencies for model creation, optional typing, UUID generation, and datetime handling
    
- L6-8: Defines user registration request structure with email and password fields

```python
class NoteMetadata(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: str = Field(default_factory=lambda: datetime.now().isoformat())
    text: str
```

- L1-4: Defines note metadata structure with auto-generated UUID and timestamp
    
- Uses `default_factory` to generate values at instantiation time rather than import time
    

### `app/services/auth.py`

**Purpose**: Handles JWT authentication, password hashing, and token validation.

**Key Imports & Globals**:

- `fastapi` dependencies for authentication flow
    
- `jose` for JWT operations
    
- `passlib` for password hashing
    
- `SECRET_KEY`, `ALGORITHM`, `ACCESS_TOKEN_EXPIRE_MINUTES` for JWT configuration
    

**Public API**:

- `verify_password()`: Compares plain text vs hashed passwords
    
- `get_password_hash()`: Creates password hash
    
- `create_access_token()`: Generates JWT tokens
    
- `get_current_user()`: Validates JWT tokens and extracts user info
    

**LINE-BY-LINE EXPLANATION**:
```python
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")
```

- L1-3: JWT configuration with hardcoded secret (security concern)
    
- L5: Password hashing context using bcrypt algorithm
    
- L6: OAuth2 scheme definition pointing to login endpoint


```python
async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str = payload.get("sub")
        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid token")
        return user_id
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")
```


- L1: Dependency that extracts token from Authorization header
    
- L3: Decodes and verifies JWT token using secret key
    
- L4-6: Extracts user ID from "sub" claim, validates presence
    
- L8: Handles invalid tokens with proper HTTP error response
    

### `app/services/chroma_service.py`

**Purpose**: Manages ChromaDB vector database operations for storing and querying notes.

**Key Imports & Globals**:

- `chromadb` for vector database client
    
- `embedding_service` for text embeddings
    
- `chroma_client`: Persistent ChromaDB client instance
    

**Public API**:

- `get_user_collection()`: Gets or creates user-specific collection
    
- `add_note()`: Stores note with embeddings
    
- `query_notes()`: Semantic search through notes
    
- `has_notes()`: Checks if user has any notes
    
- `get_all_notes_chroma()`: Retrieves all user notes
    
- `delete_note()`: Removes note by ID
    
- `edit_note()`: Updates note content and embeddings
    

**LINE-BY-LINE EXPLANATION**:

```python
chroma_client = chromadb.PersistentClient(
    path="./chroma_db",
    settings=Settings(allow_reset=True, persist_directory="./chroma_db")
)
```

- L1-4: Creates persistent ChromaDB client with storage in ./chroma_db directory
    
- `allow_reset=True` enables collection reset functionality

```python
def get_user_collection(user_id: str):
    collection_name = f"user_{user_id}_notes"
    return chroma_client.get_or_create_collection(
        name=collection_name,
        metadata={"hnsw:space": "cosine"},
        embedding_function=None  # CRITICAL FIX
    )
```

- L2: Creates unique collection name per user for data isolation
    
- L3-7: Gets existing or creates new collection with cosine similarity metric
    
- L6: Explicitly disables default embedding function since we provide our own


```python
def add_note(user_id: str, text: str) -> str:
    collection = get_user_collection(user_id)
    embedding = get_embedding(text).tolist()
    metadata = NoteMetadata(text=text)
    
    collection.add(
        documents=[text],
        embeddings=[embedding],
        metadatas=[metadata.dict()],
        ids=[metadata.id]
    )
    return metadata.id
```

- L2: Gets user-specific collection
    
- L3: Generates embedding vector for note text
    
- L4: Creates metadata with auto-generated ID and timestamp
    
- L6-11: Stores document text, embedding vector, metadata with ID
    
- Returns the generated note ID for reference
    

### `app/services/embedding_service.py`

**Purpose**: Provides text embedding functionality using SentenceTransformers.

**Key Imports & Globals**:

- `SentenceTransformer` from sentence-transformers library
    
- `model`: Pre-loaded embedding model instance
    

**Public API**:

- `get_embedding()`: Generates embedding vector for input text
    

**LINE-BY-LINE EXPLANATION**:

```python
from sentence_transformers import SentenceTransformer

model = SentenceTransformer('all-MiniLM-L6-v2')

def get_embedding(text: str) -> list:
    return model.encode(text)
```
- L3: Loads pre-trained MiniLM model (384-dimensional embeddings)
    
- L6: Encodes text string into embedding vector
    
- Model is loaded once at startup for performance
    

### `app/services/llm_utils.py`

**Purpose**: Integrates with Google Gemini API for AI-powered note summarization.

**Key Imports & Globals**:

- `os`, `httpx` for API requests
    
- `dotenv` for environment variable management
    
- `GEMINI_API_KEY`, `GEMINI_URL` for API configuration
    

**Public API**:

- `generate_summary()`: Creates AI summary from multiple notes
    

**LINE-BY-LINE EXPLANATION**:


```python
async def generate_summary(texts: list[str]) -> str:
    if not texts:
        return "No content available for summary"
    
    combined_text = "\n\n--- NOTE ---\n\n".join(texts)
    
    prompt = (
        "You are an expert note summarizer. Create a concise summary that captures the key points "
        "and common themes from these user notes. Focus on connecting insights across notes:\n\n"
        f"{combined_text}"
    )
```

- L2-3: Handles empty input edge case
    
- L5: Combines notes with separators for context preservation
    
- L7-11: Constructs detailed prompt to guide AI summarization behavior


```python
    payload = {
        "contents": [{
            "parts": [{"text": prompt}]
        }],
        "generationConfig": {
            "temperature": 0.3,
            "maxOutputTokens": 512
        }
    }
```

- L2-4: Structures payload for Gemini API with prompt text
    
- L5-8: Configures AI parameters for deterministic, concise output
    

### `main.py`

**Purpose**: Main FastAPI application with route definitions and request handling.

**Key Imports & Globals**:

- FastAPI and related dependencies
    
- All service modules and models
    
- PDF generation dependencies
    

**Public API**:

- All HTTP endpoints for the application
    

**LINE-BY-LINE EXPLANATION**:


```python
app = FastAPI()
Base.metadata.create_all(bind=engine)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)
```

- L1: Creates FastAPI application instance
    
- L2: Creates database tables if they don't exist
    
- L4-9: Configures CORS to allow all origins (permissive for development)


```python
@app.post("/notes/query")
async def query_user_notes(request: QueryRequest, current_user: User = Depends(get_current_user)):
    if not request.query.strip():
        raise HTTPException(status_code=400, detail="Query cannot be empty")
    
    user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
    
    results = await asyncio.to_thread(
        query_notes, 
        user_id, 
        request.query
    )
```

- L1: Defines POST endpoint for note queries
    
- L2: Uses dependency injection for authentication
    
- L3-4: Validates input query
    
- L6: Extracts user ID from authenticated user
    
- L8-12: Runs vector query in separate thread to avoid blocking


```python
@app.get("/notes/download")
async def download_notes(current_user: User = Depends(get_current_user)):
    try:
        user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
        notes = get_all_notes_chroma(user_id)
        
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)
```


- L1: PDF download endpoint
    
- L4: Gets all user notes from ChromaDB
    
- L6-7: Creates in-memory PDF canvas for report generation
    

## Data & Configuration

**Environment Variables**:

- `GEMINI_API_KEY`: Google Gemini API key (required for summarization)
    

**Database Schemas**:

- `User` table (SQLite):
    
    - `id`: Unique user identifier (string)
        
    - `email`: User email address (unique)
        
    - `password_hash`: Hashed password
        
    - `created_at`: Account creation timestamp
        

**ChromaDB Collections**:

- Collections named `user_{user_id}_notes` store:
    
    - Document text
        
    - Text embeddings (384-dimensional vectors)
        
    - Metadata (ID, timestamp)
        

## Runtime Behavior

**Startup**:

1. FastAPI application starts
    
2. SQLite database tables are created (if needed)
    
3. SentenceTransformer model is loaded into memory
    
4. ChromaDB client connects to persistent storage
    

**Request Flow**:

1. User authenticates via `/login` to get JWT token
    
2. Token included in Authorization header for subsequent requests
    
3. For note operations:
    
    - User-specific ChromaDB collection is accessed
        
    - Text embeddings are generated for search/storage
        
    - For queries, relevant notes are retrieved and summarized via Gemini API
        

**Shutdown**:

- No explicit cleanup code shown
    
- ChromaDB persists data to disk automatically



## Cheatsheet

**Key Commands**:

```bash
# Start application
uvicorn main:app --reload

# Test Gemini connection
python test_gemini_connection.py

# Inspect ChromaDB
python inspect_chroma_db.py
```



**API Endpoints**:

- `POST /register` - Create new account
    
- `POST /login` - Authenticate and get token
    
- `POST /notes/add` - Create new note
    
- `POST /notes/query` - Search notes
    
- `GET /notes/all` - Get all notes
    
- `DELETE /notes/delete` - Remove note
    
- `PUT /notes/edit` - Update note
    
- `GET /notes/download` - Export notes as PDF
    

## Open Questions & Assumptions

**Assumptions**:

1. Gemini API key is set in environment variables
    
2. ChromaDB directory (`./chroma_db`) is writable
    
3. SQLite database file is writable
    
4. Internet connection available for Gemini API calls
    

**Open Questions**:

1. How are ChromaDB collections managed long-term? (No cleanup mechanism shown)
    
2. Is there a limit on note size or number of notes per user?
    
3. How are embedding model updates handled?
    
4. What's the planned deployment environment?
    
5. Are there rate limits on Gemini API calls?
    

**Security Notes**:

1. JWT secret is hardcoded - should use environment variable
    
2. CORS is overly permissive (`allow_origins=["*"]`) - should be restricted in production
    
3. No visible password complexity requirements
    
4. No account lockout for failed login attempts



### Per-File Deep Dive (Continued)

#### `inspect_chroma_db.py`

**Purpose**: Utility script to inspect the contents of ChromaDB collections for debugging purposes.

**Key Imports & Globals**:

- `chromadb` for interacting with the Chroma database
    

**Public API**: None (script meant to be run directly)

**LINE-BY-LINE EXPLANATION**:


```python
import chromadb

client = chromadb.PersistentClient(path="./chroma_db")
```

- L1: Imports the ChromaDB library
    
- L3: Creates a persistent client instance pointing to the local ChromaDB storage directory

```python
def list_collections():
    print("📦 Available Collections:")
    collections = client.list_collections()
    if not collections:
        print("⚠️  No collections found.")
        return
```

- L2: Prints a header for output clarity
    
- L3: Retrieves all collections from ChromaDB
    
- L4-6: Handles the case where no collections exist

```python
    for col in collections:
        print(f" - {col.name}")
        collection = client.get_collection(name=col.name)
```

- L2: Prints each collection name
    
- L3: Fetches the collection object by name for further inspection

```python
        try:
            data = collection.get(include=["documents", "metadatas", "embeddings"])
        except Exception as e:
            print(f"   ⚠️ Failed to fetch data: {e}")
            continue
```

- L2: Attempts to retrieve all documents, metadata, and embeddings from the collection
    
- L3-5: Handles any errors during data fetching and continues to next collection


```python
        l = len(data.get('ids', []))
        print(f"   ➤ Total items: {l}")
        for i in range(l):
            if data.get("ids"):
                print(f"   ➤ Sample ID: {data['ids'][i]}")
                docs = data.get("documents")
                print(f"   ➤ Sample Doc: {docs[i]}")
                embeds = data.get("embeddings")
                print(f"   ➤ Embedding (truncated): {str(embeds[i])[:60]}...")
                print(f"   ➤ Embedding dimension: {len(embeds[i])}")
                metas = data.get("metadatas")
                print(f"   ➤ Sample Metadata: {metas[i]}")
            print("\n")
```

- L1: Gets the number of items in the collection
    
- L2: Prints the total item count
    
- L3: Loops through each item for detailed inspection
    
- L4: Checks if IDs exist
    
- L5-12: Prints ID, document text, truncated embedding, embedding dimension, and metadata for each item
    
- L13: Adds a newline for readability between items


```python
if __name__ == "__main__":
    list_collections()
```

- L2: Calls the list_collections function when the script is run directly
    

**Potential Bugs/Smells/Improvements**:

- The script assumes embeddings are always present, which might not be true for all collections.
    
- Error handling could be more specific to different types of exceptions.
    
- The output format is verbose and might be hard to parse programmatically.
    

#### `test_gemini_connection.py`

**Purpose**: Test script to verify connectivity to the Gemini API by sending a simple request.

**Key Imports & Globals**:

- `os` for environment variable access
    
- `requests` for HTTP requests
    
- `dotenv` for loading environment variables from .env file
    
- `GEMINI_API_KEY` and `GEMINI_API_URL` for API configuration
    

**Public API**: None (script meant to be run directly)

**LINE-BY-LINE EXPLANATION**:


```python
import os
import requests
from dotenv import load_dotenv

load_dotenv()
```

- L1-3: Imports necessary modules
    
- L5: Loads environment variables from .env file


```python
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"
```


- L1: Retrieves the Gemini API key from environment variables
    
- L2: Sets the Gemini API endpoint URL

```python
def test_gemini_connection():
    if not GEMINI_API_KEY:
        print("❌ Error: GEMINI_API_KEY is not set in the environment.")
        return
```

- L2-4: Checks if the API key is set and exits early if not

```python
    headers = {
        "Content-Type": "application/json"
    }
```

- L1-3: Sets HTTP headers for JSON content

```python
    prompt = "Say hello from Gemini!"
    data = {
        "contents": [{
            "parts": [{"text": prompt}]
        }]
    }
```

- L1: Defines a simple prompt for testing
    
- L2-6: Structures the request payload according to Gemini API requirements

```python
    try:
        response = requests.post(
            f"{GEMINI_API_URL}?key={GEMINI_API_KEY}",
            headers=headers,
            json=data,
            timeout=10
        )
```

- L2-7: Sends a POST request to the Gemini API with a 10-second timeout

```python
        if response.status_code == 200:
            reply = response.json()["candidates"][0]["content"]["parts"][0]["text"]
            print("✅ Gemini API is connected successfully!")
            print("Response:", reply)
        else:
            print(f"❌ Gemini API Error: {response.status_code}")
            print("Details:", response.text)
```


- L2-5: Handles successful response by parsing and printing the AI reply
    
- L6-8: Handles error responses by printing status code and details

```python
    except requests.exceptions.RequestException as e:
        print("❌ Request failed:", e)
```

- L2: Catches and prints any request-related exceptions

```python
if __name__ == "__main__":
    test_gemini_connection()
```


- L2: Calls the test function when the script is run directly
    

**Potential Bugs/Smells/Improvements**:

- The script uses synchronous requests, which might block in async environments.
    
- Error handling could be expanded to cover more specific API errors.
    
- It assumes a specific response structure, which might change with API updates.
    

### Additional Files

#### `app/__init__.py`

**Purpose**: Typically, this file marks the `app` directory as a Python package. It is likely empty or contains package initialization code.

**Content Based on Project Structure**: Since no content was provided, it is assumed to be empty or minimal. Common practice is to leave it empty unless needed for package-level imports.

#### `app/services/__init__.py`

**Purpose**: Marks the `services` directory as a Python package. This allows importing modules from the services package elsewhere.

**Content Based on Project Structure**: Similarly, no content was provided, so it is assumed to be empty or minimal.

### Data & Configuration (Supplement)

**Environment Variables**:

- `GEMINI_API_KEY`: Required for accessing the Gemini API. Must be set in the environment or in a `.env` file.
    

**Configuration Files**:

- `.env`: Should contain the Gemini API key and any other environment-specific variables.
    
- ChromaDB configuration is handled internally by the library with persistence in `./chroma_db`.
    

### Runtime Behavior (Supplement)

**Utility Scripts**:

- `inspect_chroma_db.py` can be run manually to debug ChromaDB contents.
    
- `test_gemini_connection.py` verifies that the Gemini API is accessible with the provided key.
    

**Startup Dependencies**:

- The application requires ChromaDB and SQLite databases to be accessible.
    
- The embedding model (`all-MiniLM-L6-v2`) is downloaded on first use if not already cached.
    

### Cheatsheet (Supplement)

**Utility Commands**:


```bash
# Inspect ChromaDB contents
python inspect_chroma_db.py

# Test Gemini API connection
python test_gemini_connection.py
```

### Open Questions & Assumptions (Supplement)

**Assumptions**:

- The `.env` file is present in the project root and contains `GEMINI_API_KEY`.
    
- All Python dependencies are installed (e.g., chromadb, sentence-transformers, etc.).
    
- The scripts are run from the project root directory.
    

**Open Questions**:

- How are environment variables managed in production? (e.g., using Docker, cloud platforms)
    
- Is there any cleanup mechanism for old ChromaDB collections?
    
- What is the expected performance with large numbers of notes?




### Per-File Deep Dive: main.py (Completed)

**Purpose**: The main FastAPI application file that defines all API endpoints, handles authentication, and coordinates between different services for note management, search, summarization, and PDF export.

**Key Imports & Globals**:

- FastAPI and related dependencies for web server functionality
    
- CORS middleware for cross-origin requests
    
- Pydantic models from `app.models` for request/response validation
    
- ChromaDB service functions from `app.services.chroma_service` for note operations
    
- SQLAlchemy database objects from `app.services.db` for user management
    
- Authentication utilities from `app.services.auth` for JWT handling
    
- UUID generation for user IDs
    
- Asyncio for asynchronous operations
    
- Gemini AI summarization from `app.services.llm_utils`
    
- PDF generation dependencies (BytesIO, textwrap, reportlab, datetime, Response)
    

**Public API**:

- All defined HTTP endpoints (POST/GET/DELETE/PUT) for user registration, login, note management, and health checks
    

**LINE-BY-LINE EXPLANATION**:



```python
from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from app.models import RegisterRequest, LoginRequest, NoteRequest, QueryRequest, DeleteNoteRequest, EditNoteRequest
from app.services.chroma_service import add_note, query_notes, has_notes, get_all_notes_chroma, delete_note, edit_note
from app.services.db import SessionLocal, engine, User, Base
import os
from app.services.auth import (
    get_password_hash,
    create_access_token,
    get_current_user,
    verify_password,
)
import uuid
from fastapi import HTTPException, Depends
import asyncio
from app.services.llm_utils import generate_summary


# pdf downlaod feature
# Add to top of main.py
from io import BytesIO
import textwrap
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from datetime import datetime
from fastapi import Response
```



- **L1-2**: Import FastAPI core classes and CORS middleware for handling HTTP requests and cross-origin restrictions.
    
- **L3**: Import Pydantic models to validate incoming request bodies for registration, login, notes, etc.
    
- **L4**: Import ChromaDB service functions for CRUD operations on notes stored in the vector database.
    
- **L5**: Import SQLAlchemy database session, engine, User model, and Base for ORM operations.
    
- **L6**: Import os for environment variable access (though not explicitly used in this file).
    
- **L7-12**: Import authentication functions for password hashing, JWT token creation, user validation, and password verification.
    
- **L13**: Import uuid for generating unique user identifiers.
    
- **L14**: Re-import HTTPException and Depends from FastAPI (redundant but harmless).
    
- **L15**: Import asyncio to run synchronous functions in threads and avoid blocking the event loop.
    
- **L16**: Import generate_summary function to call the Gemini API for note summarization.
    
- **L19-24**: Import modules for PDF generation: BytesIO for in-memory file handling, textwrap for text formatting, reportlab for PDF creation, datetime for timestamp parsing, and Response for returning PDF data in HTTP responses.



```python
app = FastAPI()

Base.metadata.create_all(bind=engine)
```


- **L1**: Instantiate the FastAPI application.
    
- **L3**: Create all database tables defined in the SQLAlchemy Base metadata (e.g., the User table) if they don't already exist. This ensures the database is initialized on application startup.

```python
# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)
```

- **L2-6**: Add CORS middleware to allow requests from any origin, with any HTTP method, and any headers. This is permissive for development but should be restricted in production for security.

```python
@app.post("/register")
async def register(user_in: RegisterRequest):
    db = SessionLocal()
    if db.query(User).filter(User.email == user_in.email).first():
        raise HTTPException(status_code=400, detail="Email already exists")
    user = User(id=str(uuid.uuid4()), email=user_in.email, password_hash=get_password_hash(user_in.password))
    db.add(user)
    db.commit()
    db.refresh(user)
    token = create_access_token(data={"sub": user.id})
    return {"access_token": token, "token_type": "bearer"}
```


- **L1**: Define a POST endpoint at `/register` for user registration.
    
- **L2**: The function takes a RegisterRequest object for validation.
    
- **L3**: Create a new database session.
    
- **L4-5**: Check if a user with the given email already exists; if so, raise an HTTP 400 error.
    
- **L6**: Create a new User object with a UUID-based ID, email, and hashed password.
    
- **L7**: Add the user to the database session.
    
- **L8**: Commit the transaction to persist the user.
    
- **L9**: Refresh the user object to load any database-generated attributes.
    
- **L10**: Create a JWT access token with the user ID as the subject.
    
- **L11**: Return the token in the response with a "bearer" token type.

```python
@app.post("/login")
async def login(login_data: LoginRequest):
    db = SessionLocal()
    user = db.query(User).filter(User.email == login_data.email).first()
    if not user or not verify_password(login_data.password, user.password_hash):
        raise HTTPException(status_code=400, detail="Invalid credentials")
    token = create_access_token(data={"sub": user.id})
    return {"access_token": token, "token_type": "bearer"}
```


- **L1**: Define a POST endpoint at `/login` for user authentication.
    
- **L2**: The function takes a LoginRequest object for validation.
    
- **L3**: Create a database session.
    
- **L4**: Query the user by email.
    
- **L5**: If the user doesn't exist or the password doesn't match, raise an HTTP 400 error.
    
- **L6**: Create a JWT access token with the user ID.
    
- **L7**: Return the token in the response.

```python
@app.post("/notes/add")
async def add_user_note(request: NoteRequest, current_user: User = Depends(get_current_user)):
    if not request.text.strip():
        raise HTTPException(status_code=400, detail="Text cannot be empty")
    print(f"Adding note for user: {current_user}")
    
    # Use user ID (assuming current_user is a User object with .id attribute)
    user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
    note_id = add_note(user_id, request.text)
    
    return {
        "message": "Note added successfully",
        "note_id": note_id,
        "user_id": user_id
    }
```

- **L1**: Define a POST endpoint at `/notes/add` for adding a new note. It requires authentication via the `get_current_user` dependency.
    
- **L2**: Validate that the note text is not empty or whitespace-only.
    
- **L3**: Print a debug message (should be replaced with logging in production).
    
- **L6**: Extract the user ID from the current_user object, handling both User instances and string IDs.
    
- **L7**: Call the `add_note` function from chroma_service to store the note in ChromaDB, which returns the note ID.
    
- **L9-13**: Return a success response with the note ID and user ID.


```python
@app.post("/notes/query")
async def query_user_notes(request: QueryRequest, current_user: User = Depends(get_current_user)):
    if not request.query.strip():
        raise HTTPException(status_code=400, detail="Query cannot be empty")
    
    # Get user ID properly
    user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
    
    # Get notes from vector DB (run in thread to avoid blocking)
    results = await asyncio.to_thread(
        query_notes, 
        user_id, 
        request.query
    )
    
    if not results:
        return {
            "summary": "No matching notes found",
            "results": [],
            "count": 0
        }
    
    # Extract text content for summarization
    note_texts = [res["text"] for res in results]
    
    # Generate summary asynchronously
    summary = await generate_summary(note_texts)
    
    return {
        "summary": summary,
        "results": results,
        "count": len(results)
    }
```



- **L1**: Define a POST endpoint at `/notes/query` for searching notes. Requires authentication.
    
- **L2**: Validate that the query string is not empty.
    
- **L5**: Extract the user ID.
    
- **L8-12**: Run the `query_notes` function in a separate thread to avoid blocking the event loop. This function performs a semantic search in ChromaDB.
    
- **L14-19**: If no results are found, return a response indicating no matches.
    
- **L22**: Extract the text from each note result for summarization.
    
- **L25**: Call the `generate_summary` function asynchronously to get an AI-generated summary from the Gemini API.
    
- **L27-31**: Return the summary, search results, and result count.


```python
@app.get("/notes/check")
async def check_user_notes(current_user: User = Depends(get_current_user)):
    user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
    user_has_notes = has_notes(user_id)
    return {
        "user_id": user_id,
        "has_notes": user_has_notes
    }
```


- **L1**: Define a GET endpoint at `/notes/check` to check if the user has any notes. Requires authentication.
    
- **L2**: Extract the user ID.
    
- **L3**: Call the `has_notes` function from chroma_service, which checks if the user's ChromaDB collection has any documents.
    
- **L4-7**: Return the user ID and a boolean indicating whether notes exist.


```python
@app.get("/notes/all")
async def get_all_notes(current_user: User = Depends(get_current_user)):
    try:
        # Get user ID properly
        user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
        print(f"Fetching all notes for user: {user_id}")
        
        # Get notes from ChromaDB
        notes = get_all_notes_chroma(user_id)
        print(f"Found {len(notes)} notes for user {user_id}")
        
        return {"notes": notes}
    except Exception as e:
        print(f"Error fetching all notes: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to fetch notes: {str(e)}")
```


- **L1**: Define a GET endpoint at `/notes/all` to retrieve all notes for the user. Requires authentication.
    
- **L3**: Extract the user ID.
    
- **L4**: Print a debug message with the user ID.
    
- **L7**: Call `get_all_notes_chroma` to fetch all notes from the user's ChromaDB collection.
    
- **L8**: Print the number of notes found.
    
- **L10**: Return the notes in the response.
    
- **L11-13**: If an exception occurs, log the error and raise an HTTP 500 error with details.


```python
@app.delete("/notes/delete")
async def delete_user_note(
    request: DeleteNoteRequest, 
    current_user: User = Depends(get_current_user)
):
    user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
    success = await asyncio.to_thread(delete_note, user_id, request.note_id)
    if not success:
        raise HTTPException(status_code=404, detail="Note not found")
    return {"message": "Note deleted successfully"}
```

- **L1-3**: Define a DELETE endpoint at `/notes/delete` to delete a specific note. Takes a DeleteNoteRequest and requires authentication.
    
- **L5**: Extract the user ID.
    
- **L6**: Run the `delete_note` function in a thread to delete the note from ChromaDB by ID.
    
- **L7-8**: If the deletion fails (returns False), raise an HTTP 404 error.
    
- **L9**: Return a success message.


```python
@app.get("/notes/download")
async def download_notes(current_user: User = Depends(get_current_user)):
    try:
        # Get user ID
        user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
        
        # Get all notes
        notes = get_all_notes_chroma(user_id)
        if not notes:
            raise HTTPException(status_code=404, detail="No notes found")
        
        # Create PDF in memory
        buffer = BytesIO()
        c = canvas.Canvas(buffer, pagesize=letter)
        width, height = letter
        
        # PDF styling
        margin = 40
        line_height = 14
        y_position = height - margin
        c.setFont("Helvetica-Bold", 16)
        
        # Add title
        c.drawString(margin, y_position, "Your Notes")
        y_position -= line_height * 2
        c.setFont("Helvetica", 12)
        
        # Add each note to PDF
        for note in notes:
            timestamp = note.get('timestamp', '')
            text = note.get('text', '')
            
            # Format timestamp
            formatted_time = datetime.fromisoformat(timestamp).strftime("%Y-%m-%d %H:%M") if timestamp else "Unknown time"
            
            # Add timestamp
            c.setFont("Helvetica-Bold", 12)
            c.drawString(margin, y_position, formatted_time)
            y_position -= line_height
            
            # Add note text with wrapping
            c.setFont("Helvetica", 12)
            wrapped_text = textwrap.wrap(text, width=80)
            for line in wrapped_text:
                if y_position < margin:
                    c.showPage()
                    y_position = height - margin
                c.drawString(margin + 10, y_position, line)
                y_position -= line_height
            
            # Add space between notes
            y_position -= line_height / 2
        
        c.save()
        
        # Return PDF response
        buffer.seek(0)
        return Response(
            content=buffer.getvalue(),
            media_type="application/pdf",
            headers={
                "Content-Disposition": "attachment; filename=my_notes.pdf",
                "Content-Type": "application/pdf"
            }
        )
    
    except Exception as e:
        print(f"PDF generation failed: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate PDF")
```


- **L1**: Define a GET endpoint at `/notes/download` to download all notes as a PDF. Requires authentication.
    
- **L3**: Extract the user ID.
    
- **L6**: Fetch all notes from ChromaDB.
    
- **L7-8**: If no notes are found, raise an HTTP 404 error.
    
- **L11**: Create an in-memory bytes buffer for the PDF.
    
- **L12**: Initialize a PDF canvas with letter size.
    
- **L13**: Get the width and height of the letter size for layout calculations.
    
- **L16-18**: Set PDF styling parameters: margin, line height, and initial y-position.
    
- **L19**: Set the font for the title.
    
- **L22**: Draw the title string at the top.
    
- **L23**: Move the y-position down for the content.
    
- **L24**: Set a smaller font for the content.
    
- **L27**: Iterate through each note.
    
- **L28-29**: Extract the timestamp and text from the note metadata.
    
- **L32**: Format the timestamp to a readable format, or use "Unknown time" if missing.
    
- **L35-37**: Draw the timestamp in bold font and move down one line.
    
- **L40**: Set the font for the note text.
    
- **L41**: Wrap the note text to 80 characters per line.
    
- **L42**: Iterate through each wrapped line.
    
- **L43-45**: If the y-position reaches the bottom margin, create a new page and reset the y-position.
    
- **L46**: Draw the text line with a small indentation.
    
- **L47**: Move down for the next line.
    
- **L50**: Add extra space between notes.
    
- **L52**: Save the PDF canvas to the buffer.
    
- **L55**: Move the buffer pointer to the start.
    
- **L56-64**: Return the PDF as a response with appropriate headers for file download.
    
- **L67-69**: If an error occurs during PDF generation, log it and raise an HTTP 500 error.


```python
@app.put("/notes/edit")
async def edit_user_note(
    request: EditNoteRequest, 
    current_user: User = Depends(get_current_user)
):
    user_id = current_user.id if hasattr(current_user, 'id') else str(current_user)
    
    if not request.new_text.strip():
        raise HTTPException(status_code=400, detail="Text cannot be empty")
    
    success = await asyncio.to_thread(
        edit_note, 
        user_id, 
        request.note_id, 
        request.new_text
    )
    
    if not success:
        raise HTTPException(status_code=404, detail="Note not found")
    
    return {"message": "Note updated successfully"}
```

- **L1-3**: Define a PUT endpoint at `/notes/edit` to update an existing note. Takes an EditNoteRequest and requires authentication.
    
- **L5**: Extract the user ID.
    
- **L7**: Validate that the new text is not empty.
    
- **L9-13**: Run the `edit_note` function in a thread to update the note in ChromaDB with the new text and updated timestamp.
    
- **L15-16**: If the update fails (returns False), raise an HTTP 404 error.
    
- **L18**: Return a success message.

```python
@app.get("/health")
def health_check():
    return {"status": "healthy"}
```


- **L1**: Define a GET endpoint at `/health` for health checks.
    
- **L2**: Return a simple JSON response indicating the service is healthy. This is useful for load balancers or monitoring tools.
    

**Tests & Usage Examples**:

- The code includes print statements for debugging but no formal tests.
    
- Endpoints can be tested using tools like curl or FastAPI's built-in docs at `/docs`.
    
- Example: Register a user, login to get a token, add notes, query them, and download PDF.
    

**Potential Bugs/Smells/Improvements**:

- **Hardcoded JWT Secret**: In `auth.py`, the SECRET_KEY is hardcoded; should use environment variables.
    
- **CORS Overly Permissive**: Allows all origins; should be restricted in production.
    
- **Print Statements**: Should be replaced with proper logging.
    
- **Error Handling**: Some endpoints catch exceptions broadly; could be more specific.
    
- **Database Session Management**: Sessions are created but not always closed; consider using FastAPI's dependency for sessions.
    
- **Security**: No rate limiting or password complexity requirements.
    
- **Performance**: PDF generation might be slow for many notes; could be optimized or paginated.
    
- **Dependencies**: The code assumes ChromaDB and SQLite are always available; add retry logic.
```